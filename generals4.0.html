<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generals IO ä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: headerGlow 3s infinite alternate;
        }
        
        @keyframes headerGlow {
            0% { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
            100% { box-shadow: 0 5px 25px rgba(255, 0, 0, 0.7); }
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .game-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .game-info span {
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 20px;
            min-width: 120px;
        }
        
        .game-area {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .map-container {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            overflow: auto;
            position: relative;
            max-height: 70vh;
        }
        
        .game-map {
            display: grid;
            grid-template-columns: repeat(var(--map-size, 10), 1fr);
            gap: 0px;
            margin: 0 auto;
            width: max-content;
        }
        
        .tile {
            width: 35px;
            height: 35px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            animation: tileAppear 0.3s ease-out;
        }
        
        @keyframes tileAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 10;
        }
        
        .tile.lighten::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid gold;
            border-radius: 4px;
            pointer-events: none;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .tile-content {
            z-index: 2;
            text-shadow: 1px 1px 1px black;
            font-size: 10px;
            position: relative;
            top: -6px;
            font-weight: bold;
        }
        
        .tile-type {
            font-size: 16px;
            margin-top: 2px;
            position: absolute;
            z-index: 1;
        }
        
        .controls {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 5px;
        }
        
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(to bottom, #4a00e0, #8e2de2);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #5a20e0, #9e3df2);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .dir-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 40px;
            background: rgba(50, 50, 100, 0.8);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }
        
        .dir-btn:hover {
            background: rgba(70, 70, 150, 0.9);
            transform: scale(1.05);
        }
        
        .dir-btn.north {
            grid-column: 2;
            grid-row: 1;
        }
        
        .dir-btn.south {
            grid-column: 2;
            grid-row: 3;
        }
        
        .dir-btn.west {
            grid-column: 1;
            grid-row: 2;
        }
        
        .dir-btn.east {
            grid-column: 3;
            grid-row: 2;
        }
        
        .messages {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            flex-direction: column-reverse;
        }
        
        .message {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            animation: messageAppear 0.3s;
        }
        
        @keyframes messageAppear {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .team-rank {
            background: rgba(50, 50, 80, 0.7);
            border-radius: 8px;
            padding: 10px;
        }
        
        .player-rank {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            background: rgba(30, 30, 60, 0.5);
            margin-top: 5px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .player-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .selected {
            box-shadow: 0 0 0 3px yellow;
            animation: selectedPulse 1.5s infinite;
        }
        
        @keyframes selectedPulse {
            0% { box-shadow: 0 0 0 3px yellow; }
            50% { box-shadow: 0 0 0 6px rgba(255, 255, 0, 0.5); }
            100% { box-shadow: 0 0 0 3px yellow; }
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .key-hint {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        /* æ•™ç¨‹ç•Œé¢æ ·å¼ */
        #tutorial-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
        }
        
        .tutorial-container {
            background: linear-gradient(135deg, #1a2a6c, #8e44ad);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: containerAppear 0.5s ease-out;
        }
        
        @keyframes containerAppear {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .tutorial-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
            animation: titleGlow 2s infinite alternate;
        }
        
        .tutorial-content {
            text-align: left;
            margin: 20px 0;
            font-size: 1.1rem;
            line-height: 1.6;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .tutorial-content ul {
            padding-left: 25px;
            margin: 15px 0;
        }
        
        .tutorial-content li {
            margin-bottom: 10px;
        }
        
        .tutorial-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .tutorial-button {
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 40px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        #skip-tutorial {
            background: linear-gradient(to right, #e74c3c, #c0392b);
        }
        
        #start-after-tutorial {
            background: linear-gradient(to right, #00c853, #00b248);
        }
        
        .tutorial-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        /* å¼€å§‹ç•Œé¢æ ·å¼ */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .start-container {
            background: linear-gradient(135deg, #1a2a6c, #8e44ad);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: containerAppear 0.5s ease-out;
        }
        
        .start-title {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
            animation: titleGlow 2s infinite alternate;
        }
        
        .start-content {
            display: none;
            text-align: center;
            margin: 15px 0;
        }
        
        .start-content.active {
            display: block;
        }
        
        .map-size-selector, .ai-count-selector, .difficulty-selector {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }
        
        .size-option, .ai-count-option, .difficulty-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .size-option:hover, .ai-count-option:hover, .difficulty-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
            border-color: #4fc3f7;
        }
        
        .size-option.selected, .ai-count-option.selected, .difficulty-option.selected {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            transform: scale(1.05);
        }
        
        .size-option h3, .ai-count-option h3, .difficulty-option h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #fff;
        }
        
        .size-option p, .ai-count-option p, .difficulty-option p {
            color: #ccc;
            font-size: 0.85rem;
        }
        
        .swamp-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .start-button {
            background: linear-gradient(to right, #00c853, #00b248);
            padding: 10px 25px;
            font-size: 1.1rem;
            border-radius: 40px;
            margin-top: 10px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 200, 83, 0.5);
        }
        
        .start-navigation {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 20px;
        }
        
        .start-progress {
            color: #ccc;
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        /* ç»“æŸç•Œé¢æ ·å¼ */
        #end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .end-container {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: containerAppear 0.5s ease-out;
        }
        
        .end-title {
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        .victory {
            color: #4CAF50;
            animation: victoryGlow 1.5s infinite alternate;
        }
        
        @keyframes victoryGlow {
            0% { text-shadow: 0 0 8px rgba(76, 175, 80, 0.7); }
            100% { text-shadow: 0 0 20px rgba(76, 175, 80, 1); }
        }
        
        .defeat {
            color: #f44336;
            animation: defeatGlow 1.5s infinite alternate;
        }
        
        @keyframes defeatGlow {
            0% { text-shadow: 0 0 8px rgba(244, 67, 54, 0.7); }
            100% { text-shadow: 0 0 20px rgba(244, 67, 54, 1); }
        }
        
        .end-message {
            font-size: 1.1rem;
            margin-bottom: 20px;
            color: #e0e0e0;
        }
        
        .restart-button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            padding: 10px 25px;
            font-size: 1.1rem;
            border-radius: 40px;
            margin-top: 10px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.5);
        }
        
        .game-state-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .state-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #2ecc71;
        }
        
        .state-dot.auto {
            background-color: #f1c40f;
        }
        
        .state-dot.paused {
            background-color: #e74c3c;
        }
        
        /* AIå¯è§†åŒ–æ•ˆæœ */
        .gathering {
            animation: gatheringGlow 1.5s infinite alternate;
        }
        
        @keyframes gatheringGlow {
            0% { box-shadow: 0 0 0 3px rgba(255, 165, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(255, 165, 0, 0.9); }
        }
        
        .gather-target {
            animation: targetGlow 1.5s infinite alternate;
        }
        
        @keyframes targetGlow {
            0% { box-shadow: 0 0 0 3px rgba(0, 255, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(0, 255, 0, 0.9); }
        }
        
        .ai-move {
            animation: aiMoveGlow 1.5s infinite alternate;
        }
        
        @keyframes aiMoveGlow {
            0% { box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.9); }
        }
        
        .ai-info-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        /* AIå¯è§†åŒ–æ§åˆ¶æŒ‰é’® */
        .ai-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .ai-control-btn {
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
            background: rgba(50, 50, 100, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .ai-control-btn.active {
            background: linear-gradient(to bottom, #4a00e0, #8e2de2);
            border-color: #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        .ai-control-btn:hover {
            background: rgba(70, 70, 150, 0.9);
        }
        
        .ai-status-line {
            display: flex;
            align-items: center;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .ai-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .gathering-dot { background-color: #ff8c00; }
        .target-dot { background-color: #00ff00; }
        .ai-move-dot { background-color: #ff0000; }
        
        /* éšè—éæ˜ç¤ºæ ¼å­æŒ‰é’® */
        .hide-fog-btn {
            background: linear-gradient(to bottom, #9c27b0, #673ab7);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 10px;
        }
        
        .hide-fog-btn.active {
            background: linear-gradient(to bottom, #7b1fa2, #512da8);
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
        }
        
        .hide-fog-btn:hover {
            background: rgba(123, 31, 162, 0.9);
        }
        
        /* éæ˜ç¤ºæ ¼å­æ ·å¼ */
        .tile.fog {
            background: rgba(30, 30, 30, 0.8) !important;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .tile.fog .tile-content,
        .tile.fog .tile-type {
            visibility: hidden;
        }
        
        /* ç§»åŠ¨æ¨¡å¼æŒ‰é’® */
        .move-mode-btn {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 10px;
        }
        
        .move-mode-btn.active {
            background: linear-gradient(to bottom, #2980b9, #1f6aa5);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        .move-mode-btn:hover {
            background: rgba(52, 152, 219, 0.9);
        }
        
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 30px;
                height: 30px;
                font-size: 8px;
            }
            
            .tile-content {
                font-size: 9px;
                top: -5px;
            }
            
            .tile-type {
                font-size: 14px;
            }
            
            .start-container, .end-container {
                padding: 15px;
                max-width: 400px;
            }
            
            .start-title, .end-title {
                font-size: 2.2rem;
            }
            
            .game-info {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            
            .control-buttons {
                grid-template-columns: 1fr;
            }
            
            .tutorial-container {
                max-width: 90%;
            }
        }
        
        @media (max-width: 600px) {
            .tile {
                width: 25px;
                height: 25px;
            }
            
            .tile-type {
                font-size: 12px;
            }
            
            .tile-content {
                font-size: 8px;
                top: -4px;
            }
            
            .game-info span {
                font-size: 1rem;
                padding: 6px 10px;
                min-width: 100px;
            }
            
            .ai-controls {
                grid-template-columns: 1fr;
            }
            
            .start-container, .end-container {
                padding: 12px;
                max-width: 320px;
            }
            
            .start-title, .end-title {
                font-size: 1.8rem;
            }
            
            .size-option, .ai-count-option, .difficulty-option {
                padding: 10px;
            }
            
            .size-option h3, .ai-count-option h3, .difficulty-option h3 {
                font-size: 1.2rem;
            }
            
            .start-button, .restart-button {
                padding: 8px 20px;
                font-size: 1rem;
            }
            
            .tutorial-container {
                padding: 20px 15px;
            }
            
            .tutorial-title {
                font-size: 2rem;
            }
            
            .tutorial-content {
                font-size: 1rem;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- æ•™ç¨‹ç•Œé¢ -->
    <div id="tutorial-screen">
        <div class="tutorial-container">
            <h1 class="tutorial-title">æ¸¸æˆæ•™ç¨‹</h1>
            <div class="tutorial-content">
                <p>æ¬¢è¿æ¥åˆ°Generals IOï¼è¿™æ˜¯ä¸€æ¬¾ç­–ç•¥å¾æœæ¸¸æˆï¼Œæ‚¨çš„ç›®æ ‡æ˜¯å é¢†æ‰€æœ‰é¢†åœŸå¹¶å‡»è´¥AIå¯¹æ‰‹ã€‚</p>
                <ul>
                    <li><strong>é€‰æ‹©å•ä½</strong>ï¼šç‚¹å‡»æ‚¨çš„å•ä½ï¼ˆè“è‰²æ ¼å­ï¼‰è¿›è¡Œé€‰æ‹©</li>
                    <li><strong>ç§»åŠ¨å•ä½</strong>ï¼šé€‰æ‹©å•ä½åï¼Œç‚¹å‡»æ–¹å‘æŒ‰é’®æˆ–ä½¿ç”¨WASDé”®ç§»åŠ¨</li>
                    <li><strong>ç§»åŠ¨æ¨¡å¼</strong>ï¼šä½¿ç”¨"ç§»åŠ¨æ¨¡å¼"æŒ‰é’®åˆ‡æ¢ç§»åŠ¨ä¸€åŠæˆ–å…¨éƒ¨å…µåŠ›</li>
                    <li><strong>å é¢†é¢†åœŸ</strong>ï¼šç§»åŠ¨å•ä½åˆ°ç›¸é‚»æ ¼å­ä»¥å é¢†ä¸­ç«‹æˆ–æ•Œæ–¹é¢†åœ°</li>
                    <li><strong>æ”»å‡»é¦–éƒ½</strong>ï¼šå é¢†æ•Œæ–¹é¦–éƒ½ï¼ˆğŸ‘‘ï¼‰æ¥å‡»è´¥å¯¹æ‰‹</li>
                    <li><strong>å•ä½ç”Ÿæˆ</strong>ï¼šæ¯åŠå›åˆï¼Œæ‚¨çš„é¦–éƒ½å’Œè¦å¡ä¼šç”Ÿæˆæ–°å•ä½</li>
                    <li><strong>æˆ˜äº‰è¿·é›¾</strong>ï¼šåªèƒ½çœ‹åˆ°æ‚¨å•ä½å‘¨å›´çš„åŒºåŸŸ</li>
                </ul>
                <p>ç°åœ¨å¼€å§‹æ‚¨çš„å¾æœä¹‹æ—…å§ï¼</p>
            </div>
            <div class="tutorial-buttons">
                <button class="tutorial-button" id="skip-tutorial">è·³è¿‡æ•™ç¨‹</button>
                <button class="tutorial-button" id="start-after-tutorial">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <div class="start-container">
            <h1 class="start-title">Generals IO</h1>
            <p>å¾æœé¢†åœŸï¼Œå‡»è´¥AIæœºå™¨äººï¼Œæˆä¸ºæˆ˜åœºçš„ä¸»å®°ï¼</p>
            
            <!-- ç¬¬1é¡µï¼šåœ°å›¾å¤§å° -->
            <div class="start-content active" id="start-page-1">
                <div class="map-size-selector">
                    <div class="size-option selected" data-size="10">
                        <h3>å°å‹åœ°å›¾ (10Ã—10)</h3>
                        <p>å¿«é€Ÿæˆ˜æ–—ï¼Œé€‚åˆæ–°æ‰‹å…¥é—¨</p>
                    </div>
                    <div class="size-option" data-size="15">
                        <h3>ä¸­å‹åœ°å›¾ (15Ã—15)</h3>
                        <p>å¹³è¡¡çš„æ¸¸æˆä½“éªŒï¼Œæ¨èé€‰æ‹©</p>
                    </div>
                    <div class="size-option" data-size="20">
                        <h3>å¤§å‹åœ°å›¾ (20Ã—20)</h3>
                        <p>å²è¯—çº§æˆ˜æ–—ï¼ŒæŒ‘æˆ˜ç­–ç•¥æé™</p>
                    </div>
                </div>
            </div>
            
            <!-- ç¬¬2é¡µï¼šAIæ•°é‡ -->
            <div class="start-content" id="start-page-2">
                <div class="ai-count-selector">
                    <div class="ai-count-option selected" data-count="1">
                        <h3>1åAIå¯¹æ‰‹</h3>
                        <p>ç®€å•éš¾åº¦ï¼Œé€‚åˆåˆå­¦è€…</p>
                    </div>
                    <div class="ai-count-option" data-count="2">
                        <h3>2åAIå¯¹æ‰‹</h3>
                        <p>ä¸­ç­‰éš¾åº¦ï¼ŒæŒ‘æˆ˜ç­–ç•¥</p>
                    </div>
                    <div class="ai-count-option" data-count="3">
                        <h3>3åAIå¯¹æ‰‹</h3>
                        <p>å›°éš¾éš¾åº¦ï¼Œé«˜æ‰‹å¯¹å†³</p>
                    </div>
                </div>
            </div>
            
            <!-- ç¬¬3é¡µï¼šéš¾åº¦é€‰æ‹© -->
            <div class="start-content" id="start-page-3">
                <div class="difficulty-selector">
                    <div class="difficulty-option selected" data-difficulty="normal">
                        <h3>æ™®é€šéš¾åº¦</h3>
                        <p>AIé¦–éƒ½åˆå§‹å…µåŠ›ä¸º5ï¼Œè¦å¡æ¯åŠå›åˆç”Ÿæˆ1å•ä½</p>
                    </div>
                    <div class="difficulty-option" data-difficulty="expert">
                        <h3>ä¸“å®¶éš¾åº¦</h3>
                        <p>AIé¦–éƒ½åˆå§‹å…µåŠ›ä¸º100ï¼Œæ›´å…·æŒ‘æˆ˜æ€§</p>
                    </div>
                    <div class="difficulty-option" data-difficulty="master">
                        <h3>å¤§å¸ˆéš¾åº¦</h3>
                        <p>AIé¦–éƒ½åˆå§‹å…µåŠ›ä¸º300ï¼Œè¦å¡æ¯åŠå›åˆç”Ÿæˆ2å•ä½</p>
                    </div>
                </div>
            </div>
            
            <!-- ç¬¬4é¡µï¼šæ²¼æ³½å¼€å…³ -->
            <div class="start-content" id="start-page-4">
                <div class="swamp-toggle">
                    <label for="swamp-toggle">ç”Ÿæˆæ²¼æ³½åœ°å½¢</label>
                    <label class="switch">
                        <input type="checkbox" id="swamp-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="start-navigation">
                <button class="tutorial-button" id="start-prev-button">ä¸Šä¸€é¡µ</button>
                <button class="tutorial-button" id="start-next-button">ä¸‹ä¸€é¡µ</button>
            </div>
            
            <div class="start-progress" id="start-progress">1/4</div>
            
            <div class="tutorial-buttons" style="margin-top: 20px;">
                <button class="start-button" id="start-button">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    
    <!-- ç»“æŸç•Œé¢ -->
    <div id="end-screen">
        <div class="end-container">
            <h1 class="end-title victory" id="end-title">èƒœåˆ©ï¼</h1>
            <p class="end-message" id="end-message">ä½ æˆåŠŸå¾æœäº†æ‰€æœ‰é¢†åœŸï¼</p>
            <button class="restart-button" id="restart-button">å†æ¥ä¸€å±€</button>
        </div>
    </div>
    
    <div class="container">
        <header>
            <h1>Generals IO ç½‘é¡µç‰ˆ</h1>
            <p>ç­–ç•¥å¾æœæ¸¸æˆ - å é¢†é¢†åœŸï¼Œå‡»è´¥AIæœºå™¨äººï¼</p>
            <div class="game-info">
                <span>åŠå›åˆ: <span id="halfturn">0</span></span>
                <span>è½®æ¬¡: <span id="round">0</span></span>
                <span>å½“å‰ç©å®¶: <span id="current-player">1</span></span>
            </div>
            <div class="game-state-indicator">
                <div class="state-dot auto" id="state-dot"></div>
                <span id="state-text">è‡ªåŠ¨æ¨¡å¼è¿è¡Œä¸­</span>
            </div>
        </header>
        
        <div class="game-area">
            <div class="map-container">
                <h2>æ¸¸æˆåœ°å›¾</h2>
                <div class="game-map" id="game-map"></div>
            </div>
            
            <div class="panel">
                <h2>æ¸¸æˆæ§åˆ¶</h2>
                
                <div class="direction-controls">
                    <div class="dir-btn north" data-dir="n">åŒ— (N)</div>
                    <div class="dir-btn south" data-dir="s">å— (S)</div>
                    <div class="dir-btn west" data-dir="w">è¥¿ (W)</div>
                    <div class="dir-btn east" data-dir="e">ä¸œ (E)</div>
                </div>
                
                <div class="control-buttons">
                    <button id="tick-btn">æ‰§è¡ŒåŠå›åˆ (Tick)</button>
                    <button id="clear-btn">æ¸…ç©ºé˜Ÿåˆ—</button>
                    <button id="auto-btn">å…³é—­è‡ªåŠ¨</button>
                </div>
                
                <div class="key-hint">
                    <p>é”®ç›˜æ§åˆ¶: W (åŒ—), A (è¥¿), S (å—), D (ä¸œ)</p>
                    <p>é€‰æ‹©æ ¼å­åï¼ŒæŒ‰æ–¹å‘é”®ç§»åŠ¨å•ä½</p>
                </div>
                
                <!-- æ–°å¢çš„ç§»åŠ¨æ¨¡å¼æŒ‰é’® -->
                <div class="move-mode-btn" id="move-mode-btn">ç§»åŠ¨å…¨éƒ¨å…µåŠ›</div>
                
                <div class="hide-fog-btn active" id="hide-fog-btn">æ˜¾ç¤ºæ‰€æœ‰æ ¼å­</div>
                
                <div class="ai-controls">
                    <div class="ai-control-btn" id="gathering-btn">é›†ç»“å…µåŠ›</div>
                    <div class="ai-control-btn" id="target-btn">æ”»å‡»ç›®æ ‡</div>
                    <div class="ai-control-btn" id="aimove-btn">AIç§»åŠ¨</div>
                </div>
                
                <div class="color-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>ç©å®¶ 1</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>AIæœºå™¨äºº (ç©å®¶2)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>AIæœºå™¨äºº (ç©å®¶3)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f1c40f;"></div>
                        <span>AIæœºå™¨äºº (ç©å®¶4)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #95a5a6;"></div>
                        <span>ä¸­ç«‹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #d35400;"></div>
                        <span>ğŸ‘‘ é¦–éƒ½</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2c3e50;"></div>
                        <span>â›°ï¸ å±±åŒº</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8e44ad;"></div>
                        <span>ğŸ° è¦å¡</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #16a085;"></div>
                        <span>ğŸŒŠ æ²¼æ³½</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8c00;"></div>
                        <span>AIé›†ç»“ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #333;"></div>
                        <span>æˆ˜äº‰è¿·é›¾</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="panel">
                <h2>æ¸¸æˆæ¶ˆæ¯</h2>
                <div class="messages" id="messages"></div>
            </div>
            
            <div class="panel">
                <h2>é˜Ÿä¼æ’å</h2>
                <div class="leaderboard" id="leaderboard"></div>
                
                <div class="ai-info-panel" id="ai-info">
                    <strong>AIç­–ç•¥ä¿¡æ¯</strong>
                    <div id="ai-status">ç­‰å¾…æ¸¸æˆå¼€å§‹</div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot gathering-dot"></div>
                        <span id="gathering-status">é›†ç»“å…µåŠ›: å…³é—­</span>
                    </div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot target-dot"></div>
                        <span id="target-status">æ”»å‡»ç›®æ ‡: å…³é—­</span>
                    </div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot ai-move-dot"></div>
                        <span id="aimove-status">AIç§»åŠ¨: å…³é—­</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆå¸¸é‡
        const TileType = {
            MOUNTAIN: 1,
            STRONGHOLD: 2,
            PLAIN: 3,
            CAPITAL: 4,
            SWAMP: 5
        };
        
        const Direction = {
            NORTH: 0,
            SOUTH: 1,
            WEST: 2,
            EAST: 3
        };
        
        const DIRECTION_DELTAS = {
            [Direction.NORTH]: [0, -1],
            [Direction.SOUTH]: [0, 1],
            [Direction.WEST]: [-1, 0],
            [Direction.EAST]: [1, 0]
        };
        
        // ç©å®¶é¢œè‰²æ˜ å°„
        const PLAYER_COLORS = {
            0: "#95a5a6",
            1: "#3498db",
            2: "#e74c3c",
            3: "#2ecc71",
            4: "#f1c40f"
        };
        
        // åœ°å½¢é¢œè‰²
        const TERRAIN_COLORS = {
            [TileType.MOUNTAIN]: "#2c3e50",
            [TileType.STRONGHOLD]: "#8e44ad",
            [TileType.PLAIN]: "#27ae60",
            [TileType.CAPITAL]: "#d35400",
            [TileType.SWAMP]: "#16a085",
            GATHERING: "#ff8c00"
        };
        
        // åœ°å½¢ç¬¦å·
        const TERRAIN_SYMBOLS = {
            [TileType.MOUNTAIN]: "â›°ï¸",
            [TileType.STRONGHOLD]: "ğŸ°",
            [TileType.PLAIN]: "â¬œ",
            [TileType.CAPITAL]: "ğŸ‘‘",
            [TileType.SWAMP]: "ğŸŒŠ"
        };
        
        class Player {
            constructor(id, teamId, capital) {
                this.id = id;
                this.teamId = teamId;
                this.capital = capital;
                this.isDefeated = false;
                this.orderQueue = [];
            }
        }
        
        class Tile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.type = TileType.PLAIN;
                this.ownerId = 0;
                this.units = 0;
                this.aiState = null;
                this.visible = false;
            }
            
            isPassable() {
                return this.type !== TileType.MOUNTAIN;
            }
        }
        
        class GeneralsGame {
            constructor(width = 10, height = 10) {
                this.width = width;
                this.height = height;
                this.map = this.createMap(width, height);
                this.players = {};
                this.teams = {};
                this.playerMovePriority = [];
                this.currentPriorityIndex = 0;
                this.halfturnCount = 0;
                this.roundCount = 0;
                this.gameState = {
                    halfturnId: 0,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                this.initNeutralTeam();
                this.selectedTile = null;
                this.autoMode = true;
                this.gameOver = false;
                this.winner = null;
                this.aiStatus = "ç­‰å¾…æ¸¸æˆå¼€å§‹";
                this.aiCount = 1;
                this.hideFog = true;
                this.difficulty = "normal";
                this.generateSwamps = true;
                this.aiDecisionCache = {};
            }
            
            createMap(width, height) {
                const map = [];
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(new Tile(x, y));
                    }
                    map.push(row);
                }
                return map;
            }
            
            initNeutralTeam() {
                this.teams[0] = {
                    id: 0,
                    players: [],
                    visionCache: new Set()
                };
            }
            
            addPlayer(playerId, teamId, capitalX, capitalY) {
                if (this.players[playerId]) return;
                
                const player = new Player(playerId, teamId, { x: capitalX, y: capitalY });
                this.players[playerId] = player;
                
                if (!this.teams[teamId]) {
                    this.teams[teamId] = {
                        id: teamId,
                        players: [],
                        visionCache: new Set()
                    };
                }
                this.teams[teamId].players.push(player);
                
                const capitalTile = this.map[capitalY][capitalX];
                capitalTile.type = TileType.CAPITAL;
                capitalTile.ownerId = playerId;
                capitalTile.units = 5;
                
                this.playerMovePriority.push(playerId);
            }
            
            isMapConnected() {
                const visited = Array(this.height).fill().map(() => Array(this.width).fill(false));
                let regions = 0;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (!visited[y][x] && this.map[y][x].isPassable()) {
                            regions++;
                            if (regions > 1) return false;
                            this.floodFill(x, y, visited);
                        }
                    }
                }
                return true;
            }
            
            floodFill(x, y, visited) {
                const queue = [{x, y}];
                visited[y][x] = true;
                
                while (queue.length > 0) {
                    const {x, y} = queue.shift();
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            const tile = this.map[ny][nx];
                            if (!visited[ny][nx] && tile.isPassable()) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                }
            }
            
            updateVisibility() {
                // é‡ç½®æ‰€æœ‰æ ¼å­çš„å¯è§æ€§
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.map[y][x].visible = false;
                    }
                }
                
                // åªæ›´æ–°ç©å®¶1çš„è§†é‡
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === 1) {
                            // æ˜¾ç¤ºå‘¨å›´3x3åŒºåŸŸ
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                                        this.map[ny][nx].visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // ç¡®ä¿ç©å®¶é¦–éƒ½å§‹ç»ˆå¯è§
                if (this.players[1] && this.players[1].capital) {
                    const capital = this.players[1].capital;
                    this.map[capital.y][capital.x].visible = true;
                }
            }
            
            appendOrder(playerId, srcX, srcY, direction, moveHalf) {
                if (!this.players[playerId] || this.players[playerId].isDefeated) return;
                
                this.players[playerId].orderQueue.push({
                    playerId,
                    srcX,
                    srcY,
                    direction,
                    moveHalf
                });
            }
            
            clearQueue(playerId) {
                if (this.players[playerId]) {
                    this.players[playerId].orderQueue = [];
                }
            }
            
            toggleAutoMode() {
                this.autoMode = !this.autoMode;
                return this.autoMode;
            }
            
            toggleFogVisibility() {
                this.hideFog = !this.hideFog;
                return this.hideFog;
            }
            
            tick() {
                if (this.gameOver) return this.gameState;
                
                this.halfturnCount++;
                this.gameState = {
                    halfturnId: this.halfturnCount,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                
                this.clearAIStates();
                this.generateRobotOrders();
                
                let processedOrders = [];
                let maxLoops = this.width * this.height;
                let hasOrders = true;
                
                let playerOrder = [];
                if (this.playerMovePriority.length > 0) {
                    playerOrder = [
                        ...this.playerMovePriority.slice(this.currentPriorityIndex),
                        ...this.playerMovePriority.slice(0, this.currentPriorityIndex)
                    ];
                    this.currentPriorityIndex = (this.currentPriorityIndex + 1) % this.playerMovePriority.length;
                }
                
                while (hasOrders && maxLoops-- > 0) {
                    hasOrders = false;
                    
                    for (let i = 0; i < playerOrder.length; i++) {
                        const playerId = playerOrder[i];
                        const player = this.players[playerId];
                        
                        if (!player || player.isDefeated) continue;
                        
                        if (player.orderQueue.length > 0) {
                            hasOrders = true;
                            const order = player.orderQueue.shift();
                            if (this.processMoveOrder(order)) {
                                processedOrders.push(order);
                            }
                        }
                    }
                }
                
                this.generateUnits();
                
                // æ¯åŠå›åˆç»“æŸåæ›´æ–°æˆ˜äº‰è¿·é›¾
                this.updateVisibility();
                
                this.gameState.alivePlayers = Object.keys(this.players)
                    .filter(playerId => {
                        const player = this.players[playerId];
                        return !player.isDefeated;
                    });
                
                if (this.halfturnCount % 50 === 0) {
                    this.roundCount++;
                }
                
                if (this.halfturnCount % 5 === 0) {
                    this.gameState.messages.push(`åŠå›åˆ ${this.halfturnCount} å®Œæˆ`);
                }
                
                this.updateLeaderboard();
                this.checkGameEnd();
                
                return this.gameState;
            }
            
            clearAIStates() {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.map[y][x].aiState = null;
                    }
                }
            }
            
            generateRobotOrders() {
                // ä½¿ç”¨ç¼“å­˜ä¼˜åŒ–AIå†³ç­–
                if (this.halfturnCount % 2 !== 0) return;
                
                for (let aiId = 2; aiId <= 1 + this.aiCount; aiId++) {
                    const robotPlayerId = aiId;
                    const robot = this.players[robotPlayerId];
                    
                    if (!robot || robot.isDefeated) continue;
                    
                    // ä½¿ç”¨ç¼“å­˜ä¼˜åŒ–AIå†³ç­–
                    const cacheKey = `${robotPlayerId}-${this.halfturnCount}`;
                    if (this.aiDecisionCache[cacheKey]) {
                        this.players[robotPlayerId].orderQueue = this.aiDecisionCache[cacheKey];
                        continue;
                    }
                    
                    let orderGenerated = false;
                    
                    const swampTiles = this.findSwampTiles(robotPlayerId);
                    if (swampTiles.length > 0) {
                        for (const tile of swampTiles) {
                            if (tile.units > 1) {
                                this.executeSwampEscapeStrategy(tile, robotPlayerId);
                                orderGenerated = true;
                                break;
                            }
                        }
                    }
                    
                    if (!orderGenerated) {
                        const attackTarget = this.findAttackTarget(robotPlayerId);
                        if (attackTarget) {
                            this.executeAdvancedAttackStrategy(attackTarget.srcTile, attackTarget.targetTile, robotPlayerId);
                            orderGenerated = true;
                        }
                    }
                    
                    if (!orderGenerated) {
                        const expansionTarget = this.findNeutralExpansion(robotPlayerId);
                        if (expansionTarget) {
                            const dir = this.getDirection(expansionTarget.srcTile, expansionTarget.destTile);
                            if (dir !== null) {
                                this.players[robotPlayerId].orderQueue.push({
                                    playerId: robotPlayerId,
                                    srcX: expansionTarget.srcTile.x,
                                    srcY: expansionTarget.srcTile.y,
                                    direction: dir,
                                    moveHalf: false
                                });
                                this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} å‘ä¸­æ€§åœŸåœ°(${expansionTarget.destTile.x},${expansionTarget.destTile.y})æ‰©å¼ `);
                                orderGenerated = true;
                            }
                        }
                    }
                    
                    if (!orderGenerated) {
                        const otherAICapitals = [];
                        for (let otherId = 2; otherId <= 1 + this.aiCount; otherId++) {
                            if (otherId !== robotPlayerId) {
                                const otherAI = this.players[otherId];
                                if (otherAI && !otherAI.isDefeated) {
                                    otherAICapitals.push(otherAI.capital);
                                }
                            }
                        }
                        
                        if (otherAICapitals.length > 0) {
                            const targetCapital = otherAICapitals[Math.floor(Math.random() * otherAICapitals.length)];
                            const expansionTarget = this.findExpansionTarget(robotPlayerId, targetCapital);
                            if (expansionTarget) {
                                this.executeExpansionStrategy(expansionTarget, targetCapital, robotPlayerId);
                                orderGenerated = true;
                            }
                        }
                    }
                    
                    if (!orderGenerated) {
                        this.executeRandomStrategy(robotPlayerId);
                    }
                    
                    // ç¼“å­˜å†³ç­–ç»“æœ
                    this.aiDecisionCache[cacheKey] = [...this.players[robotPlayerId].orderQueue];
                }
            }
            
            findAttackTarget(robotPlayerId) {
                // ä¼˜åŒ–ï¼šåªæ£€æŸ¥è¾¹ç•Œæ ¼å­
                let bestSource = null;
                let bestTarget = null;
                let bestScore = -Infinity;
                
                // è¾¹ç•Œæ£€æŸ¥ä¼˜åŒ–
                const borderTiles = [];
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId !== robotPlayerId) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ºè¾¹ç•Œæ ¼å­
                        let isBorder = false;
                        for (const dir of Object.values(Direction)) {
                            const [dx, dy] = DIRECTION_DELTAS[dir];
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                            
                            const neighbor = this.map[ny][nx];
                            if (neighbor.ownerId !== robotPlayerId && neighbor.isPassable()) {
                                isBorder = true;
                                break;
                            }
                        }
                        
                        if (isBorder) {
                            borderTiles.push(tile);
                        }
                    }
                }
                
                // åªæ£€æŸ¥è¾¹ç•Œæ ¼å­
                for (const srcTile of borderTiles) {
                    if (srcTile.units <= 1) continue;
                    
                    for (const dir of Object.values(Direction)) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const destX = srcTile.x + dx;
                        const destY = srcTile.y + dy;
                        
                        if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                        
                        const destTile = this.map[destY][destX];
                        if (!destTile.isPassable()) continue;
                        
                        if ((destTile.ownerId !== 0 && destTile.ownerId !== robotPlayerId) || 
                            (destTile.ownerId === 0 && destTile.type === TileType.STRONGHOLD)) {
                            let score = 0;
                            
                            if (destTile.type === TileType.STRONGHOLD) score += 30;
                            if (destTile.type === TileType.CAPITAL) score += 50;
                            score += 20 - destTile.units;
                            if (srcTile.type === TileType.SWAMP) score -= 10;
                            
                            if (srcTile.units > destTile.units) {
                                score += 20;
                            }
                            
                            const supportUnits = this.findNearbySupportUnits(srcTile, destTile, robotPlayerId);
                            if (supportUnits > destTile.units) {
                                score += 15;
                            }
                            
                            if (destTile.ownerId === 0 && destTile.type === TileType.STRONGHOLD) {
                                score += 20;
                            }
                            
                            if (destTile.ownerId >= 2 && destTile.ownerId <= 4) {
                                score += 25;
                            }
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestSource = srcTile;
                                bestTarget = destTile;
                            }
                        }
                    }
                }
                
                return bestSource ? { srcTile: bestSource, targetTile: bestTarget } : null;
            }
            
            executeAdvancedAttackStrategy(srcTile, targetTile, robotPlayerId) {
                const requiredUnits = targetTile.units + 1;
                this.aiStatus = `ç©å®¶${robotPlayerId}å‘ç°ç›®æ ‡: (${targetTile.x},${targetTile.y}) éœ€è¦å…µåŠ›: ${requiredUnits}`;
                
                if (srcTile.units > requiredUnits) {
                    this.aiStatus = `ç©å®¶${robotPlayerId}å…µåŠ›å……è¶³ï¼Œç›´æ¥æ”»å‡»ç›®æ ‡ (${targetTile.x},${targetTile.y})`;
                    this.executeAttackStrategy(srcTile, targetTile, robotPlayerId);
                    return;
                }
                
                this.aiStatus = `ç©å®¶${robotPlayerId}å…µåŠ›ä¸è¶³ï¼Œå¼€å§‹é›†ç»“ (${srcTile.units}/${requiredUnits})`;
                const gatherResult = this.gatherForces(srcTile, targetTile, robotPlayerId, requiredUnits);
                
                if (gatherResult.success) {
                    const path = this.bfsPath(srcTile.x, srcTile.y, targetTile.x, targetTile.y, robotPlayerId);
                    
                    if (path && path.length > 1) {
                        const nextStep = path[1];
                        const dir = this.getDirection({x: path[0].x, y: path[0].y}, nextStep);
                        
                        if (dir !== null) {
                            this.players[robotPlayerId].orderQueue.push({
                                playerId: robotPlayerId,
                                srcX: srcTile.x,
                                srcY: srcTile.y,
                                direction: dir,
                                moveHalf: false
                            });
                            
                            srcTile.aiState = 'ai-move';
                            targetTile.aiState = 'target';
                            
                            this.gameState.messages.push(
                                `æœºå™¨äººç©å®¶${robotPlayerId}é›†ç»“æˆåŠŸï¼ä»(${srcTile.x},${srcTile.y})å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨`
                            );
                        }
                    }
                } else {
                    this.aiStatus = `ç©å®¶${robotPlayerId}æ— æ³•é›†ç»“è¶³å¤Ÿå…µåŠ› (${gatherResult.totalUnits}/${requiredUnits})ï¼Œå°è¯•æ”»å‡»`;
                    this.executeAttackStrategy(srcTile, targetTile, robotPlayerId);
                }
            }
            
            gatherForces(gatheringPoint, targetTile, playerId, requiredUnits) {
                let totalGathered = gatheringPoint.units;
                const gatheringQueue = [];
                
                const nearbyAllies = this.findNearbyAllies(gatheringPoint, playerId, 5);
                nearbyAllies.sort((a, b) => b.units - a.units || (Math.abs(a.x - gatheringPoint.x) + Math.abs(a.y - gatheringPoint.y)) - (Math.abs(b.x - gatheringPoint.x) + Math.abs(b.y - gatheringPoint.y)));
                
                if (nearbyAllies.length > 0) {
                    const ally = nearbyAllies[0];
                    if (ally.units > 1) {
                        const path = this.optimizedBfsPath(ally.x, ally.y, gatheringPoint.x, gatheringPoint.y, playerId);
                        
                        if (path && path.length > 1) {
                            const nextStep = path[1];
                            const dir = this.getDirection({x: ally.x, y: ally.y}, nextStep);
                            
                            if (dir !== null && this.isMoveValid(ally.x, ally.y, dir, playerId)) {
                                gatheringQueue.push({
                                    playerId: playerId,
                                    srcX: ally.x,
                                    srcY: ally.y,
                                    direction: dir,
                                    moveHalf: false
                                });
                                
                                ally.aiState = 'gathering';
                                gatheringPoint.aiState = 'gathering';
                                targetTile.aiState = 'target';
                                
                                const moveUnits = ally.units - 1;
                                totalGathered += moveUnits;
                                
                                this.gameState.messages.push(
                                    `æœºå™¨äººç©å®¶${playerId}é›†ç»“å…µåŠ›: ä»(${ally.x},${ally.y})ç§»åŠ¨${moveUnits}å•ä½åˆ°é›†ç»“ç‚¹(${gatheringPoint.x},${gatheringPoint.y})`
                                );
                            }
                        }
                    }
                }
                
                gatheringQueue.forEach(order => {
                    this.players[playerId].orderQueue.push(order);
                });
                
                return {
                    success: totalGathered >= requiredUnits,
                    totalUnits: totalGathered
                };
            }
            
            isMoveValid(srcX, srcY, direction, playerId) {
                const [dx, dy] = DIRECTION_DELTAS[direction];
                const destX = srcX + dx;
                const destY = srcY + dy;
                
                if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) {
                    return false;
                }
                
                const srcTile = this.map[srcY][srcX];
                const destTile = this.map[destY][destX];
                
                if (srcTile.ownerId !== playerId || srcTile.units <= 1) {
                    return false;
                }
                
                if (!destTile.isPassable()) {
                    return false;
                }
                
                return true;
            }
            
            optimizedBfsPath(startX, startY, targetX, targetY, playerId, maxDepth = 20) {
                const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
                const visited = new Set([`${startX},${startY}`]);
                
                while (queue.length > 0) {
                    const { x, y, path, cost } = queue.shift();
                    
                    if (x === targetX && y === targetY) {
                        return [...path, { x, y }];
                    }
                    
                    if (path.length >= maxDepth) continue;
                    
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                        
                        const tile = this.map[ny][nx];
                        if (!tile.isPassable() || 
                            (tile.type === TileType.STRONGHOLD && tile.ownerId !== playerId)) {
                            continue;
                        }
                        
                        const key = `${nx},${ny}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            
                            let moveCost = 1;
                            if (tile.type === TileType.SWAMP) moveCost = 3;
                            
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...path, { x, y }],
                                cost: cost + moveCost
                            });
                        }
                    }
                    
                    queue.sort((a, b) => a.cost - b.cost);
                }
                
                return null;
            }
            
            findNearbyAllies(centerTile, playerId, radius) {
                const allies = [];
                const minX = Math.max(0, centerTile.x - radius);
                const maxX = Math.min(this.width - 1, centerTile.x + radius);
                const minY = Math.max(0, centerTile.y - radius);
                const maxY = Math.min(this.height - 1, centerTile.y + radius);
                
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === playerId && tile.units > 0) {
                            allies.push(tile);
                        }
                    }
                }
                
                return allies;
            }
            
            executeAttackStrategy(srcTile, targetTile, robotPlayerId) {
                const path = this.bfsPath(srcTile.x, srcTile.y, targetTile.x, targetTile.y, robotPlayerId);
                
                if (path && path.length > 1) {
                    const steps = Math.min(3, path.length - 1);
                    
                    for (let i = 0; i < steps; i++) {
                        const nextStep = path[i + 1];
                        const dir = this.getDirection({x: path[i].x, y: path[i].y}, nextStep);
                        
                        if (dir !== null) {
                            this.players[robotPlayerId].orderQueue.push({
                                playerId: robotPlayerId,
                                srcX: path[i].x,
                                srcY: path[i].y,
                                direction: dir,
                                moveHalf: false
                            });
                            
                            srcTile.aiState = 'ai-move';
                            targetTile.aiState = 'target';
                            
                            this.gameState.messages.push(`æœºå™¨äººç©å®¶${robotPlayerId}å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨: æ­¥éª¤ ${i+1}/${steps}`);
                        }
                    }
                } else {
                    const dir = this.getDirection(srcTile, targetTile);
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        srcTile.aiState = 'ai-move';
                        targetTile.aiState = 'target';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶${robotPlayerId}ç›´æ¥å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨`);
                    }
                }
            }
            
            findExpansionTarget(robotPlayerId, humanCapital) {
                let bestTile = null;
                let minDistance = Infinity;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId !== robotPlayerId || tile.units <= 1 || tile.type === TileType.SWAMP) continue;
                        
                        const distance = Math.abs(x - humanCapital.x) + Math.abs(y - humanCapital.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestTile = tile;
                        }
                    }
                }
                
                return bestTile;
            }
            
            executeExpansionStrategy(srcTile, humanCapital, robotPlayerId) {
                const path = this.bfsPath(srcTile.x, srcTile.y, humanCapital.x, humanCapital.y, robotPlayerId);
                
                if (path && path.length > 1) {
                    const nextStep = path[1];
                    const dir = this.getDirection({x: srcTile.x, y: srcTile.y}, nextStep);
                    
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        srcTile.aiState = 'ai-move';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶${robotPlayerId}å‘ç›®æ ‡(${humanCapital.x},${humanCapital.y})ç§»åŠ¨`);
                    }
                } else {
                    const dir = this.getDirection(srcTile, humanCapital);
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        srcTile.aiState = 'ai-move';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶${robotPlayerId}ç›´æ¥å‘ç›®æ ‡(${humanCapital.x},${humanCapital.y})ç§»åŠ¨`);
                    }
                }
            }
            
            findSwampTiles(robotPlayerId) {
                const tiles = [];
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === robotPlayerId && 
                            tile.type === TileType.SWAMP && 
                            tile.units > 0) {
                            tiles.push(tile);
                        }
                    }
                }
                return tiles;
            }
            
            executeSwampEscapeStrategy(tile, robotPlayerId) {
                if (tile.units <= 1) return;
                
                const directions = Object.values(Direction);
                const validDirections = [];
                
                for (const dir of directions) {
                    const [dx, dy] = DIRECTION_DELTAS[dir];
                    const destX = tile.x + dx;
                    const destY = tile.y + dy;
                    
                    if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                    
                    const destTile = this.map[destY][destX];
                    if (!destTile.isPassable()) continue;
                    
                    validDirections.push(dir);
                }
                
                if (validDirections.length > 0) {
                    let bestDir = validDirections[0];
                    let bestScore = -Infinity;
                    
                    for (const dir of validDirections) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const destX = tile.x + dx;
                        const destY = tile.y + dy;
                        const destTile = this.map[destY][destX];
                        
                        let score = 0;
                        if (destTile.type === TileType.PLAIN) score += 20;
                        if (destTile.type === TileType.STRONGHOLD) score += 10;
                        if (destTile.type === TileType.SWAMP) score -= 30;
                        
                        if (destTile.ownerId === robotPlayerId) {
                            score += 5;
                        } else if (destTile.ownerId === 0) {
                            score += 15;
                        } else {
                            score += 10;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestDir = dir;
                        }
                    }
                    
                    this.players[robotPlayerId].orderQueue.push({
                        playerId: robotPlayerId,
                        srcX: tile.x,
                        srcY: tile.y,
                        direction: bestDir,
                        moveHalf: false
                    });
                    
                    tile.aiState = 'ai-move';
                    
                    this.gameState.messages.push(`æœºå™¨äººç©å®¶${robotPlayerId}é€ƒç¦»æ²¼æ³½(${tile.x},${tile.y})ï¼Œæ–¹å‘: ${this.getDirectionName(bestDir)}`);
                }
            }
            
            findNeutralExpansion(robotPlayerId) {
                const expansionTargets = [];
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId !== robotPlayerId || tile.units <= 1) continue;
                        
                        const directions = Object.values(Direction);
                        for (const dir of directions) {
                            const [dx, dy] = DIRECTION_DELTAS[dir];
                            const destX = x + dx;
                            const destY = y + dy;
                            
                            if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                            
                            const destTile = this.map[destY][destX];
                            if (destTile.ownerId === 0 && destTile.isPassable()) {
                                expansionTargets.push({
                                    srcTile: tile,
                                    destTile: destTile,
                                    score: destTile.units + (destTile.type === TileType.PLAIN ? 10 : 0)
                                });
                            }
                        }
                    }
                }
                
                if (expansionTargets.length > 0) {
                    expansionTargets.sort((a, b) => a.score - b.score);
                    return expansionTargets[0];
                }
                
                return null;
            }
            
            executeRandomStrategy(robotPlayerId) {
                const movableTiles = [];
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === robotPlayerId && 
                            tile.units > 1) {
                            movableTiles.push(tile);
                        }
                    }
                }
                
                if (movableTiles.length > 0) {
                    const tile = movableTiles[Math.floor(Math.random() * movableTiles.length)];
                    const directions = Object.values(Direction);
                    const validDirections = [];
                    const directionScores = [];
                    
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const destX = tile.x + dx;
                        const destY = tile.y + dy;
                        
                        if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                        
                        const destTile = this.map[destY][destX];
                        if (!destTile.isPassable() || destTile.type === TileType.SWAMP) continue;
                        
                        validDirections.push(dir);
                        
                        let score = 1;
                        if (destTile.ownerId === 0) score += 3;
                        if (destTile.type === TileType.PLAIN) score += 2;
                        directionScores.push(score);
                    }
                    
                    if (validDirections.length > 0) {
                        const totalScore = directionScores.reduce((a, b) => a + b, 0);
                        let randomScore = Math.random() * totalScore;
                        
                        let selectedDir = validDirections[0];
                        for (let i = 0; i < validDirections.length; i++) {
                            randomScore -= directionScores[i];
                            if (randomScore <= 0) {
                                selectedDir = validDirections[i];
                                break;
                            }
                        }
                        
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: tile.x,
                            srcY: tile.y,
                            direction: selectedDir,
                            moveHalf: Math.random() > 0.5
                        });
                        
                        tile.aiState = 'ai-move';
                    }
                }
            }
            
            bfsPath(startX, startY, targetX, targetY, playerId, maxDepth = 20) {
                const queue = [{ x: startX, y: startY, path: [] }];
                const visited = new Set([`${startX},${startY}`]);
                
                while (queue.length > 0) {
                    const { x, y, path } = queue.shift();
                    
                    if (x === targetX && y === targetY) {
                        return [...path, { x, y }];
                    }
                    
                    if (path.length >= maxDepth) continue;
                    
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                        
                        const tile = this.map[ny][nx];
                        if (!tile.isPassable() || 
                            (tile.type === TileType.STRONGHOLD && tile.ownerId !== playerId)) {
                            continue;
                        }
                        
                        const key = `${nx},${ny}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...path, { x, y }]
                            });
                        }
                    }
                }
                
                return null;
            }
            
            getDirection(srcTile, destTile) {
                const dx = destTile.x - srcTile.x;
                const dy = destTile.y - srcTile.y;
                
                if (dx === 1 && dy === 0) return Direction.EAST;
                if (dx === -1 && dy === 0) return Direction.WEST;
                if (dx === 0 && dy === 1) return Direction.SOUTH;
                if (dx === 0 && dy === -1) return Direction.NORTH;
                
                return null;
            }
            
            findNearbySupportUnits(srcTile, targetTile, playerId) {
                let totalSupport = 0;
                const directions = Object.values(Direction);
                
                for (const dir of directions) {
                    const [dx, dy] = DIRECTION_DELTAS[dir];
                    const checkX = srcTile.x + dx;
                    const checkY = srcTile.y + dy;
                    
                    if (checkX < 0 || checkX >= this.width || checkY < 0 || checkY >= this.height) continue;
                    
                    const tile = this.map[checkY][checkX];
                    
                    if (tile.ownerId === playerId && tile.units > 1) {
                        totalSupport += tile.units - 1;
                    }
                }
                
                return totalSupport;
            }
            
            getDirectionName(direction) {
                switch (direction) {
                    case Direction.NORTH: return "åŒ—";
                    case Direction.SOUTH: return "å—";
                    case Direction.WEST: return "è¥¿";
                    case Direction.EAST: return "ä¸œ";
                    default: return "æœªçŸ¥";
                }
            }
            
            processMoveOrder(order) {
                const { playerId, srcX, srcY, direction, moveHalf } = order;
                const srcTile = this.map[srcY][srcX];
                
                if (srcTile.ownerId !== playerId || srcTile.units <= 1) return false;
                
                const [dx, dy] = DIRECTION_DELTAS[direction];
                const destX = srcX + dx;
                const destY = srcY + dy;
                
                if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) {
                    return false;
                }
                
                const destTile = this.map[destY][destX];
                
                if (!destTile.isPassable()) return false;
                
                const moveUnits = moveHalf ? Math.floor(srcTile.units / 2) : srcTile.units - 1;
                srcTile.units -= moveUnits;
                
                if (destTile.ownerId === 0) {
                    if (moveUnits > destTile.units) {
                        destTile.ownerId = playerId;
                        destTile.units = moveUnits - destTile.units;
                    } else {
                        destTile.units = destTile.units - moveUnits;
                    }
                } else if (destTile.ownerId === playerId) {
                    destTile.units += moveUnits;
                } else {
                    const enemyPlayerId = destTile.ownerId;
                    const enemyUnits = destTile.units;
                    
                    if (moveUnits > enemyUnits) {
                        destTile.ownerId = playerId;
                        destTile.units = moveUnits - enemyUnits;
                        
                        if (destTile.type === TileType.CAPITAL) {
                            this.handleCapitalCapture(playerId, enemyPlayerId, destTile);
                        }
                    } else {
                        destTile.units = enemyUnits - moveUnits;
                    }
                }
                
                return true;
            }
            
            handleCapitalCapture(attackerId, defenderId, capitalTile) {
                const defender = this.players[defenderId];
                if (!defender) return;
                
                defender.isDefeated = true;
                this.gameState.defeatedPlayers.push(defenderId);
                this.gameState.messages.push(`ç©å®¶ ${attackerId} å é¢†äº†ç©å®¶ ${defenderId} çš„é¦–éƒ½ï¼`);
                
                capitalTile.type = TileType.STRONGHOLD;
                
                for (const row of this.map) {
                    for (const tile of row) {
                        if (tile.ownerId === defenderId) {
                            tile.ownerId = attackerId;
                            tile.units = Math.floor(tile.units / 2) + 1;
                        }
                    }
                }
            }
            
            generateUnits() {
                for (const row of this.map) {
                    for (const tile of row) {
                        if (tile.ownerId === 0) continue;
                        
                        if (tile.type === TileType.CAPITAL || tile.type === TileType.STRONGHOLD) {
                            let generateAmount = 1;
                            
                            if (tile.ownerId > 1 && this.difficulty === "master") {
                                generateAmount = 2;
                            }
                            
                            tile.units += generateAmount;
                        }
                        
                        if (tile.type === TileType.SWAMP && tile.units > 0) {
                            tile.units -= 1;
                        }
                        
                        if (this.halfturnCount % 25 === 0) {
                            tile.units += 1;
                        }
                    }
                }
            }
            
            updateLeaderboard() {
                const teamStats = [];
                
                for (const teamId in this.teams) {
                    if (teamId === "0") continue;
                    
                    const team = this.teams[teamId];
                    let totalUnits = 0;
                    let totalTiles = 0;
                    const playerStats = [];
                    
                    for (const player of team.players) {
                        let playerUnits = 0;
                        let playerTiles = 0;
                        
                        for (const row of this.map) {
                            for (const tile of row) {
                                if (tile.ownerId === player.id) {
                                    playerUnits += tile.units;
                                    playerTiles++;
                                }
                            }
                        }
                        
                        totalUnits += playerUnits;
                        totalTiles += playerTiles;
                        
                        playerStats.push({
                            playerId: player.id,
                            defeated: player.isDefeated,
                            units: playerUnits,
                            tiles: playerTiles
                        });
                    }
                    
                    playerStats.sort((a, b) => b.units - a.units);
                    
                    teamStats.push({
                        teamId,
                        totalUnits,
                        totalTiles,
                        players: playerStats
                    });
                }
                
                teamStats.sort((a, b) => b.totalUnits - a.totalUnits);
                this.gameState.leaderboard = teamStats;
            }
            
            selectTile(x, y) {
                this.selectedTile = { x, y };
                return this.map[y][x];
            }
            
            checkGameEnd() {
                const humanPlayer = this.players[1];
                if (humanPlayer && humanPlayer.isDefeated) {
                    this.gameOver = true;
                    this.winner = 2;
                    return;
                }
                
                let humanWins = true;
                for (const playerId in this.players) {
                    if (playerId !== "1") {
                        const player = this.players[playerId];
                        if (!player.isDefeated) {
                            humanWins = false;
                        }
                    }
                }
                
                if (humanWins) {
                    this.gameOver = true;
                    this.winner = 1;
                }
            }
            
            resetGame(width, height) {
                this.width = width;
                this.height = height;
                this.map = this.createMap(width, height);
                this.players = {};
                this.teams = {};
                this.playerMovePriority = [];
                this.currentPriorityIndex = 0;
                this.halfturnCount = 0;
                this.roundCount = 0;
                this.gameState = {
                    halfturnId: 0,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                this.initNeutralTeam();
                this.selectedTile = null;
                this.autoMode = true;
                this.gameOver = false;
                this.winner = null;
                this.aiStatus = "æ¸¸æˆå·²é‡ç½®";
                this.aiDecisionCache = {};
            }
        }
        
        class GameUI {
            constructor() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.initialize());
                } else {
                    this.initialize();
                }
            }
            
            initialize() {
                this.game = new GeneralsGame(10, 10);
                this.initDOMReferences();
                this.setupEventListeners();
                
                this.tutorialScreen.style.display = 'flex';
                this.startScreen.style.display = 'none';
                this.currentStartPage = 1;
                this.updateStartProgress();
                
                this.renderMap();
                this.updateUI();
                
                this.showGathering = false;
                this.showTarget = false;
                this.showAiMove = false;
                this.moveHalfMode = false; // é»˜è®¤ç§»åŠ¨å…¨éƒ¨å…µåŠ›
            }
            
            initGame(width = 10, height = 10) {
                this.game.resetGame(width, height);
                this.game.addPlayer(1, 1, 1, 1);
                
                const aiCount = parseInt(document.querySelector('.ai-count-option.selected').dataset.count);
                this.game.aiCount = aiCount;
                
                const difficulty = document.querySelector('.difficulty-option.selected').dataset.difficulty;
                this.game.difficulty = difficulty;
                
                const generateSwamps = document.getElementById('swamp-toggle').checked;
                this.game.generateSwamps = generateSwamps;
                
                const aiPositions = [];
                
                if (aiCount >= 1) {
                    aiPositions.push({x: width-2, y: height-2});
                }
                if (aiCount >= 2) {
                    aiPositions.push({x: 1, y: height-2});
                }
                if (aiCount >= 3) {
                    aiPositions.push({x: width-2, y: 1});
                }
                
                for (let i = 0; i < aiCount; i++) {
                    const pos = aiPositions[i];
                    this.game.addPlayer(2 + i, 2 + i, pos.x, pos.y);
                }
                
                let connected = false;
                let attempts = 0;
                const maxAttempts = 20;
                
                while (!connected && attempts < maxAttempts) {
                    attempts++;
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const tile = this.game.map[y][x];
                            if (tile.ownerId !== 0) continue;
                            
                            const terrainTypes = [
                                TileType.PLAIN, TileType.PLAIN, TileType.PLAIN, TileType.PLAIN,
                                TileType.MOUNTAIN, TileType.MOUNTAIN,
                                ...(generateSwamps ? [TileType.SWAMP] : []),
                                TileType.STRONGHOLD
                            ];
                            
                            tile.type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                        }
                    }
                    
                    connected = this.game.isMapConnected();
                    
                    if (!connected) {
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (this.game.map[y][x].ownerId === 0) {
                                    this.game.map[y][x].type = TileType.PLAIN;
                                }
                            }
                        }
                    }
                }
                
                if (!connected) {
                    this.addMessage("è­¦å‘Šï¼šåœ°å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åœ°å›¾");
                }
                
                this.setInitialUnits();
                this.tileElements = null;
                this.gameMap.style.setProperty('--map-size', width);
                this.game.updateVisibility();
                this.addMessage(`æ¸¸æˆå¼€å§‹ï¼åœ°å›¾å¤§å°: ${width}x${height}ï¼ŒAIæ•°é‡: ${aiCount}ï¼Œéš¾åº¦: ${difficulty}`);
                this.addMessage("ç‚¹å‡»ä½ çš„å•ä½ï¼Œç„¶åé€‰æ‹©ç§»åŠ¨æ–¹å‘");
            }
            
            setInitialUnits() {
                for (let y = 0; y < this.game.height; y++) {
                    for (let x = 0; x < this.game.width; x++) {
                        const tile = this.game.map[y][x];
                        if (tile.type === TileType.STRONGHOLD && tile.ownerId === 0) {
                            tile.units = Math.floor(Math.random() * 31) + 10;
                        }
                        if (tile.type === TileType.CAPITAL && tile.ownerId > 1) {
                            if (this.game.difficulty === "expert") {
                                tile.units = 100;
                            } else if (this.game.difficulty === "master") {
                                tile.units = 300;
                            }
                        }
                    }
                }
            }
            
            initDOMReferences() {
                this.gameMap = document.getElementById('game-map');
                this.halfturnEl = document.getElementById('halfturn');
                this.roundEl = document.getElementById('round');
                this.currentPlayerEl = document.getElementById('current-player');
                this.messagesEl = document.getElementById('messages');
                this.leaderboardEl = document.getElementById('leaderboard');
                this.tickBtn = document.getElementById('tick-btn');
                this.clearBtn = document.getElementById('clear-btn');
                this.autoBtn = document.getElementById('auto-btn');
                this.stateDot = document.getElementById('state-dot');
                this.stateText = document.getElementById('state-text');
                this.aiInfoEl = document.getElementById('ai-info');
                this.aiStatusEl = document.getElementById('ai-status');
                this.gatheringStatusEl = document.getElementById('gathering-status');
                this.targetStatusEl = document.getElementById('target-status');
                this.aimoveStatusEl = document.getElementById('aimove-status');
                this.hideFogBtn = document.getElementById('hide-fog-btn');
                this.moveModeBtn = document.getElementById('move-mode-btn'); // æ–°å¢çš„ç§»åŠ¨æ¨¡å¼æŒ‰é’®
                
                this.tutorialScreen = document.getElementById('tutorial-screen');
                this.skipTutorialBtn = document.getElementById('skip-tutorial');
                this.startAfterTutorialBtn = document.getElementById('start-after-tutorial');
                
                this.startScreen = document.getElementById('start-screen');
                this.sizeOptions = document.querySelectorAll('.size-option');
                this.startButton = document.getElementById('start-button');
                this.aiCountOptions = document.querySelectorAll('.ai-count-option');
                this.difficultyOptions = document.querySelectorAll('.difficulty-option');
                this.startPrevButton = document.getElementById('start-prev-button');
                this.startNextButton = document.getElementById('start-next-button');
                this.startProgress = document.getElementById('start-progress');
                
                this.endScreen = document.getElementById('end-screen');
                this.endTitle = document.getElementById('end-title');
                this.endMessage = document.getElementById('end-message');
                this.restartButton = document.getElementById('restart-button');
                
                this.gatheringBtn = document.getElementById('gathering-btn');
                this.targetBtn = document.getElementById('target-btn');
                this.aimoveBtn = document.getElementById('aimove-btn');
            }
            
            renderMap() {
                if (!this.tileElements || 
                    this.tileElements.length !== this.game.height || 
                    this.tileElements[0].length !== this.game.width) {
                    this.tileElements = [];
                    this.gameMap.innerHTML = '';
                    this.gameMap.style.setProperty('--map-size', this.game.width);
                    
                    for (let y = 0; y < this.game.height; y++) {
                        const rowElements = [];
                        for (let x = 0; x < this.game.width; x++) {
                            const tile = this.game.map[y][x];
                            const tileEl = this.createTileElement(tile);
                            this.gameMap.appendChild(tileEl);
                            rowElements.push(tileEl);
                        }
                        this.tileElements.push(rowElements);
                    }
                } else {
                    for (let y = 0; y < this.game.height; y++) {
                        for (let x = 0; x < this.game.width; x++) {
                            const tile = this.game.map[y][x];
                            const tileEl = this.tileElements[y][x];
                            this.updateTileElement(tileEl, tile);
                        }
                    }
                }
                
                this.aiStatusEl.textContent = this.game.aiStatus;
            }
            
            createTileElement(tile) {
                const tileEl = document.createElement('div');
                tileEl.className = 'tile';
                
                if (tile.lighten) {
                    tileEl.classList.add('lighten');
                }
                
                const bgColor = PLAYER_COLORS[tile.ownerId] || TERRAIN_COLORS[tile.type] || '#27ae60';
                tileEl.style.background = `linear-gradient(135deg, ${this.adjustColor(bgColor, -20)}, ${bgColor})`;
                
                tileEl.innerHTML = `
                    <div class="tile-content">${tile.units > 0 ? tile.units : ''}</div>
                    <div class="tile-type">${TERRAIN_SYMBOLS[tile.type] || ''}</div>
                `;
                
                tileEl.addEventListener('click', () => this.handleTileClick(tile.x, tile.y));
                
                return tileEl;
            }
            
            updateTileElement(tileEl, tile) {
                if (this.game.selectedTile && 
                    this.game.selectedTile.x === tile.x && 
                    this.game.selectedTile.y === tile.y) {
                    tileEl.classList.add('selected');
                } else {
                    tileEl.classList.remove('selected');
                }
                
                if (tile.lighten) {
                    tileEl.classList.add('lighten');
                } else {
                    tileEl.classList.remove('lighten');
                }
                
                tileEl.classList.remove('gathering', 'gather-target', 'ai-move');
                
                if (tile.aiState === 'gathering' && this.showGathering) {
                    tileEl.classList.add('gathering');
                } else if (tile.aiState === 'target' && this.showTarget) {
                    tileEl.classList.add('gather-target');
                } else if (tile.aiState === 'ai-move' && this.showAiMove) {
                    tileEl.classList.add('ai-move');
                }
                
                if (this.game.hideFog && !tile.visible) {
                    tileEl.classList.add('fog');
                } else {
                    tileEl.classList.remove('fog');
                }
                
                if (tile.type === TileType.CAPITAL && tile.ownerId === 1) {
                    tileEl.classList.remove('fog');
                }
                
                const bgColor = PLAYER_COLORS[tile.ownerId] || TERRAIN_COLORS[tile.type] || '#27ae60';
                tileEl.style.background = `linear-gradient(135deg, ${this.adjustColor(bgColor, -20)}, ${bgColor})`;
                
                const contentEl = tileEl.querySelector('.tile-content');
                if (contentEl) {
                    contentEl.textContent = tile.units > 0 ? tile.units : '';
                }
                
                const typeEl = tileEl.querySelector('.tile-type');
                if (typeEl) {
                    typeEl.textContent = TERRAIN_SYMBOLS[tile.type] || '';
                }
            }
            
            adjustColor(color, amount) {
                let usePound = false;
                
                if (color[0] === "#") {
                    color = color.slice(1);
                    usePound = true;
                }
                
                const num = parseInt(color, 16);
                let r = (num >> 16) + amount;
                
                if (r > 255) r = 255;
                else if (r < 0) r = 0;
                
                let b = ((num >> 8) & 0x00FF) + amount;
                
                if (b > 255) b = 255;
                else if (b < 0) b = 0;
                
                let g = (num & 0x0000FF) + amount;
                
                if (g > 255) g = 255;
                else if (g < 0) g = 0;
                
                return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
            }
            
            handleTileClick(x, y) {
                this.game.selectTile(x, y);
                this.renderMap();
            }
            
            handleDirectionClick(dir) {
                if (!this.game.selectedTile) return;
                
                const playerId = 1;
                const { x, y } = this.game.selectedTile;
                
                const directionMap = {
                    'n': Direction.NORTH,
                    's': Direction.SOUTH,
                    'w': Direction.WEST,
                    'e': Direction.EAST
                };
                
                if (directionMap[dir] !== undefined) {
                    this.game.appendOrder(playerId, x, y, directionMap[dir], this.moveHalfMode);
                    this.game.selectedTile = null;
                    this.renderMap();
                    this.addMessage(`ç©å®¶ ${playerId}: ä» (${x},${y}) å‘ ${dir.toUpperCase()} ç§»åŠ¨ (${this.moveHalfMode ? 'ä¸€åŠ' : 'å…¨éƒ¨'}å…µåŠ›)`);
                    
                    if (this.game.autoMode) {
                        setTimeout(() => {
                            this.game.tick();
                            this.updateUI();
                            this.checkGameEnd();
                        }, 300);
                    }
                }
            }
            
            toggleMoveMode() {
                this.moveHalfMode = !this.moveHalfMode;
                this.moveModeBtn.textContent = this.moveHalfMode ? "ç§»åŠ¨ä¸€åŠå…µåŠ›" : "ç§»åŠ¨å…¨éƒ¨å…µåŠ›";
                this.moveModeBtn.classList.toggle('active', this.moveHalfMode);
                this.addMessage(`ç§»åŠ¨æ¨¡å¼: ${this.moveHalfMode ? 'ç§»åŠ¨ä¸€åŠå…µåŠ›' : 'ç§»åŠ¨å…¨éƒ¨å…µåŠ›'}`);
            }
            
            toggleAIVisualization(type) {
                switch(type) {
                    case 'gathering':
                        this.showGathering = !this.showGathering;
                        this.gatheringBtn.classList.toggle('active', this.showGathering);
                        this.gatheringStatusEl.textContent = `é›†ç»“å…µåŠ›: ${this.showGathering ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIé›†ç»“å…µåŠ›å¯è§†åŒ–: ${this.showGathering ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                    case 'target':
                        this.showTarget = !this.showTarget;
                        this.targetBtn.classList.toggle('active', this.showTarget);
                        this.targetStatusEl.textContent = `æ”»å‡»ç›®æ ‡: ${this.showTarget ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIæ”»å‡»ç›®æ ‡å¯è§†åŒ–: ${this.showTarget ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                    case 'aimove':
                        this.showAiMove = !this.showAiMove;
                        this.aimoveBtn.classList.toggle('active', this.showAiMove);
                        this.aimoveStatusEl.textContent = `AIç§»åŠ¨: ${this.showAiMove ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIç§»åŠ¨å¯è§†åŒ–: ${this.showAiMove ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                }
                this.renderMap();
            }
            
            toggleFogVisibility() {
                const isFogHidden = this.game.toggleFogVisibility();
                this.hideFogBtn.textContent = isFogHidden ? "æ˜¾ç¤ºæ‰€æœ‰æ ¼å­" : "éšè—éæ˜ç¤ºæ ¼å­";
                this.hideFogBtn.classList.toggle('active', isFogHidden);
                this.addMessage(`æˆ˜äº‰è¿·é›¾: ${isFogHidden ? 'å¼€å¯' : 'å…³é—­'}`);
                this.renderMap();
            }
            
            updateStartProgress() {
                this.startProgress.textContent = `${this.currentStartPage}/4`;
            }
            
            changeStartPage(direction) {
                document.getElementById(`start-page-${this.currentStartPage}`).classList.remove('active');
                
                if (direction === 'next') {
                    this.currentStartPage = Math.min(4, this.currentStartPage + 1);
                } else {
                    this.currentStartPage = Math.max(1, this.currentStartPage - 1);
                }
                
                document.getElementById(`start-page-${this.currentStartPage}`).classList.add('active');
                this.updateStartProgress();
                
                if (this.currentStartPage === 4) {
                    this.startButton.style.display = 'block';
                } else {
                    this.startButton.style.display = 'none';
                }
            }
            
            setupEventListeners() {
                document.querySelectorAll('.dir-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.handleDirectionClick(btn.dataset.dir);
                    });
                });
                
                this.tickBtn.addEventListener('click', () => {
                    this.game.tick();
                    this.updateUI();
                    this.checkGameEnd();
                });
                
                this.clearBtn.addEventListener('click', () => {
                    this.game.clearQueue(1);
                    this.addMessage(`å·²æ¸…ç©ºç©å®¶é˜Ÿåˆ—`);
                });
                
                this.autoBtn.addEventListener('click', () => {
                    const isAuto = this.game.toggleAutoMode();
                    this.autoBtn.textContent = isAuto ? "å…³é—­è‡ªåŠ¨" : "è‡ªåŠ¨æ¨¡å¼";
                    this.autoBtn.style.background = isAuto 
                        ? "linear-gradient(to bottom, #e74c3c, #c0392b)" 
                        : "linear-gradient(to bottom, #4a00e0, #8e2de2)";
                    
                    if (isAuto) {
                        this.stateDot.className = "state-dot auto";
                        this.stateText.textContent = "è‡ªåŠ¨æ¨¡å¼è¿è¡Œä¸­";
                        this.addMessage("å·²å¼€å¯è‡ªåŠ¨æ¨¡å¼");
                    } else {
                        this.stateDot.className = "state-dot paused";
                        this.stateText.textContent = "æ¸¸æˆæš‚åœä¸­";
                        this.addMessage("å·²å…³é—­è‡ªåŠ¨æ¨¡å¼");
                    }
                });
                
                // æ–°å¢ç§»åŠ¨æ¨¡å¼æŒ‰é’®äº‹ä»¶
                this.moveModeBtn.addEventListener('click', () => {
                    this.toggleMoveMode();
                });
                
                this.gatheringBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('gathering');
                });
                
                this.targetBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('target');
                });
                
                this.aimoveBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('aimove');
                });
                
                this.hideFogBtn.addEventListener('click', () => {
                    this.toggleFogVisibility();
                });
                
                document.addEventListener('keydown', (e) => {
                    if (!this.game.selectedTile) return;
                    
                    const keyMap = {
                        'w': 'n',
                        'a': 'w',
                        's': 's',
                        'd': 'e'
                    };
                    
                    if (keyMap[e.key.toLowerCase()]) {
                        this.handleDirectionClick(keyMap[e.key.toLowerCase()]);
                    }
                });
                
                this.sizeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.sizeOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                this.aiCountOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.aiCountOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                this.difficultyOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.difficultyOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                this.startPrevButton.addEventListener('click', () => {
                    this.changeStartPage('prev');
                });
                
                this.startNextButton.addEventListener('click', () => {
                    this.changeStartPage('next');
                });
                
                this.startButton.addEventListener('click', () => {
                    const selectedOption = document.querySelector('.size-option.selected');
                    const size = parseInt(selectedOption.dataset.size);
                    this.initGame(size, size);
                    this.startScreen.style.display = 'none';
                    this.updateUI();
                });
                
                this.restartButton.addEventListener('click', () => {
                    this.endScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                    this.currentStartPage = 1;
                    document.querySelectorAll('.start-content').forEach(el => el.classList.remove('active'));
                    document.getElementById('start-page-1').classList.add('active');
                    this.startButton.style.display = 'none';
                    this.updateStartProgress();
                });
                
                // æ•™ç¨‹ç•Œé¢äº‹ä»¶
                this.skipTutorialBtn.addEventListener('click', () => {
                    this.tutorialScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                });
                
                this.startAfterTutorialBtn.addEventListener('click', () => {
                    this.tutorialScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                });
            }
            
            updateUI() {
                this.halfturnEl.textContent = this.game.halfturnCount;
                this.roundEl.textContent = this.game.roundCount;
                this.currentPlayerEl.textContent = 1;
                this.renderMap();
                this.renderMessages();
                this.renderLeaderboard();
            }
            
            addMessage(text) {
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                messageEl.textContent = text;
                this.messagesEl.prepend(messageEl);
                
                if (this.messagesEl.children.length > 10) {
                    this.messagesEl.removeChild(this.messagesEl.lastChild);
                }
            }
            
            renderMessages() {
                this.messagesEl.innerHTML = '';
                
                if (this.game.gameState.messages.length === 0) {
                    this.addMessage("ç­‰å¾…æ¸¸æˆå¼€å§‹...");
                    return;
                }
                
                this.game.gameState.messages.forEach(msg => {
                    this.addMessage(msg);
                });
            }
            
            renderLeaderboard() {
                this.leaderboardEl.innerHTML = '';
                
                if (this.game.gameState.leaderboard.length === 0) {
                    this.leaderboardEl.innerHTML = '<div class="team-rank">æš‚æ— æ’åæ•°æ®</div>';
                    return;
                }
                
                this.game.gameState.leaderboard.forEach(team => {
                    const teamEl = document.createElement('div');
                    teamEl.className = 'team-rank';
                    teamEl.innerHTML = `<strong>é˜Ÿä¼ ${team.teamId}</strong> - å•ä½: ${team.totalUnits}, é¢†åœ°: ${team.totalTiles}`;
                    
                    team.players.forEach(player => {
                        const playerEl = document.createElement('div');
                        playerEl.className = 'player-rank';
                        
                        const playerColor = PLAYER_COLORS[player.playerId] || '#95a5a6';
                        
                        playerEl.innerHTML = `
                            <span>
                                <span class="player-color" style="background:${playerColor}"></span>
                                ç©å®¶ ${player.playerId} - ${player.defeated ? 'å·²å¤±è´¥' : 'æ´»è·ƒ'}
                            </span>
                            <span>å•ä½: ${player.units}, é¢†åœ°: ${player.tiles}</span>
                        `;
                        teamEl.appendChild(playerEl);
                    });
                
                    this.leaderboardEl.appendChild(teamEl);
                });
            }
            
            checkGameEnd() {
                if (this.game.gameOver) {
                    if (this.game.winner === 1) {
                        this.showEndScreen(true, "ä½ æˆåŠŸå¾æœäº†æ‰€æœ‰é¢†åœŸï¼");
                    } else {
                        this.showEndScreen(false, "ä½ çš„é¦–éƒ½å·²è¢«å é¢†ï¼Œä¸‹æ¬¡å†æ¥å†å‰ï¼");
                    }
                }
            }
            
            showEndScreen(isVictory, message) {
                if (isVictory) {
                    this.endTitle.textContent = "èƒœåˆ©ï¼";
                    this.endTitle.className = "end-title victory";
                } else {
                    this.endTitle.textContent = "å¤±è´¥";
                    this.endTitle.className = "end-title defeat";
                }
                
                this.endMessage.textContent = message;
                this.endScreen.style.display = "flex";
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const gameUI = new GameUI();
        });
    </script>
</body>
</html>