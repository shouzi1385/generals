<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generals IO ç½‘é¡µç‰ˆ - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: headerGlow 3s infinite alternate;
        }
        
        @keyframes headerGlow {
            0% { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
            100% { box-shadow: 0 5px 25px rgba(255, 0, 0, 0.7); }
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .game-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .game-info span {
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 20px;
            min-width: 120px;
        }
        
        .game-area {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .map-container {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            overflow: auto;
            position: relative;
            max-height: 70vh;
        }
        
        .game-map {
            display: grid;
            grid-template-columns: repeat(var(--map-size, 10), 1fr);
            gap: 0px;
            margin: 0 auto;
            width: max-content;
        }
        
        .tile {
            /* ç¼©å°åœ°å›¾æ ¼å­å¤§å° */
            width: 35px;
            height: 35px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            animation: tileAppear 0.3s ease-out;
        }
        
        @keyframes tileAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 10;
        }
        
        .tile.lighten::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid gold;
            border-radius: 4px;
            pointer-events: none;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .tile-content {
            z-index: 2;
            text-shadow: 1px 1px 1px black;
            /* è°ƒæ•´å­—ä½“å¤§å° */
            font-size: 10px;
            position: relative;
            top: -6px;
            font-weight: bold;
        }
        
        .tile-type {
            /* è°ƒæ•´ç¬¦å·å¤§å° */
            font-size: 16px;
            margin-top: 2px;
            position: absolute;
            z-index: 1;
        }
        
        .controls {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 5px;
        }
        
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(to bottom, #4a00e0, #8e2de2);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #5a20e0, #9e3df2);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(30deg);
            transition: all 0.6s;
        }
        
        button:hover::after {
            transform: translateY(100%) rotate(30deg);
        }
        
        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .dir-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 40px;
            background: rgba(50, 50, 100, 0.8);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }
        
        .dir-btn:hover {
            background: rgba(70, 70, 150, 0.9);
            transform: scale(1.05);
        }
        
        .dir-btn.north {
            grid-column: 2;
            grid-row: 1;
        }
        
        .dir-btn.south {
            grid-column: 2;
            grid-row: 3;
        }
        
        .dir-btn.west {
            grid-column: 1;
            grid-row: 2;
        }
        
        .dir-btn.east {
            grid-column: 3;
            grid-row: 2;
        }
        
        .messages {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            flex-direction: column-reverse;
        }
        
        .message {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            animation: messageAppear 0.3s;
        }
        
        @keyframes messageAppear {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .team-rank {
            background: rgba(50, 50, 80, 0.7);
            border-radius: 8px;
            padding: 10px;
        }
        
        .player-rank {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            background: rgba(30, 30, 60, 0.5);
            margin-top: 5px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .selected {
            box-shadow: 0 0 0 3px yellow;
            animation: selectedPulse 1.5s infinite;
        }
        
        @keyframes selectedPulse {
            0% { box-shadow: 0 0 0 3px yellow; }
            50% { box-shadow: 0 0 0 6px rgba(255, 255, 0, 0.5); }
            100% { box-shadow: 0 0 0 3px yellow; }
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .key-hint {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        /* æ•™ç¨‹ç•Œé¢æ ·å¼ */
        #tutorial-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
        }
        
        .tutorial-container {
            background: linear-gradient(135deg, #0f1a4a, #6a1b9a);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 800px;
            width: 90%;
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.5);
            animation: containerAppear 0.5s ease-out;
        }
        
        .tutorial-title {
            font-size: 2.5rem;
            margin-bottom: 25px;
            color: #4fc3f7;
            text-shadow: 0 0 15px rgba(79, 195, 247, 0.8);
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px rgba(79, 195, 247, 0.7); }
            100% { text-shadow: 0 0 20px rgba(79, 195, 247, 1); }
        }
        
        .tutorial-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            text-align: left;
            margin: 20px 0;
        }
        
        .tutorial-step {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(79, 195, 247, 0.3);
            transition: all 0.3s;
        }
        
        .tutorial-step:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(79, 195, 247, 0.3);
        }
        
        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #4fc3f7;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .tutorial-step h3 {
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: #fff;
            display: flex;
            align-items: center;
        }
        
        .tutorial-step p {
            color: #ccc;
            font-size: 1.05rem;
            line-height: 1.6;
        }
        
        .tutorial-image {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .tutorial-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .tutorial-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .tutorial-button {
            background: linear-gradient(to right, #00c853, #00b248);
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 40px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .tutorial-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 200, 83, 0.5);
        }
        
        .tutorial-button.skip {
            background: linear-gradient(to right, #ff9800, #f57c00);
        }
        
        /* å¼€å§‹ç•Œé¢æ ·å¼ */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .start-container {
            background: linear-gradient(135deg, #1a2a6c, #8e44ad);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: containerAppear 0.5s ease-out;
        }
        
        @keyframes containerAppear {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .start-title {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
            animation: titleGlow 2s infinite alternate;
        }
        
        .map-size-selector {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }
        
        .size-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .size-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
            border-color: #4fc3f7;
        }
        
        .size-option.selected {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            transform: scale(1.05);
        }
        
        .size-option h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #fff;
        }
        
        .size-option p {
            color: #ccc;
            font-size: 0.85rem;
        }
        
        .start-button {
            background: linear-gradient(to right, #00c853, #00b248);
            padding: 10px 25px;
            font-size: 1.1rem;
            border-radius: 40px;
            margin-top: 10px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 200, 83, 0.5);
        }
        
        /* ç»“æŸç•Œé¢æ ·å¼ */
        #end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .end-container {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: containerAppear 0.5s ease-out;
        }
        
        .end-title {
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        .victory {
            color: #4CAF50;
            animation: victoryGlow 1.5s infinite alternate;
        }
        
        @keyframes victoryGlow {
            0% { text-shadow: 0 0 8px rgba(76, 175, 80, 0.7); }
            100% { text-shadow: 0 0 20px rgba(76, 175, 80, 1); }
        }
        
        .defeat {
            color: #f44336;
            animation: defeatGlow 1.5s infinite alternate;
        }
        
        @keyframes defeatGlow {
            0% { text-shadow: 0 0 8px rgba(244, 67, 54, 0.7); }
            100% { text-shadow: 0 0 20px rgba(244, 67, 54, 1); }
        }
        
        .end-message {
            font-size: 1.1rem;
            margin-bottom: 20px;
            color: #e0e0e0;
        }
        
        .restart-button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            padding: 10px 25px;
            font-size: 1.1rem;
            border-radius: 40px;
            margin-top: 10px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.5);
        }
        
        .game-state-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .state-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #2ecc71;
        }
        
        .state-dot.auto {
            background-color: #f1c40f;
        }
        
        .state-dot.paused {
            background-color: #e74c3c;
        }
        
        /* AIé›†ç»“å¯è§†åŒ–æ•ˆæœ */
        .gathering {
            animation: gatheringGlow 1.5s infinite alternate;
        }
        
        @keyframes gatheringGlow {
            0% { box-shadow: 0 0 0 3px rgba(255, 165, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(255, 165, 0, 0.9); }
        }
        
        .gather-target {
            animation: targetGlow 1.5s infinite alternate;
        }
        
        @keyframes targetGlow {
            0% { box-shadow: 0 0 0 3px rgba(0, 255, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(0, 255, 0, 0.9); }
        }
        
        .ai-move {
            animation: aiMoveGlow 1.5s infinite alternate;
        }
        
        @keyframes aiMoveGlow {
            0% { box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.5); }
            100% { box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.9); }
        }
        
        .ai-info-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        /* AIå¯è§†åŒ–æ§åˆ¶æŒ‰é’® */
        .ai-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .ai-control-btn {
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
            background: rgba(50, 50, 100, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .ai-control-btn.active {
            background: linear-gradient(to bottom, #4a00e0, #8e2de2);
            border-color: #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        .ai-control-btn:hover {
            background: rgba(70, 70, 150, 0.9);
        }
        
        .ai-status-line {
            display: flex;
            align-items: center;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .ai-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .gathering-dot { background-color: #ff8c00; }
        .target-dot { background-color: #00ff00; }
        .ai-move-dot { background-color: #ff0000; }
        
        /* AIæ•°é‡é€‰æ‹©å™¨ */
        .ai-count-selector {
            margin: 12px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .ai-count-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .ai-count-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
            border-color: #4fc3f7;
        }
        
        .ai-count-option.selected {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
        }
        
        .ai-count-option h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
        }
        
        .ai-count-option p {
            font-size: 0.85rem;
        }
        
        /* éšè—éæ˜ç¤ºæ ¼å­æŒ‰é’® */
        .hide-fog-btn {
            background: linear-gradient(to bottom, #9c27b0, #673ab7);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 10px;
        }
        
        .hide-fog-btn.active {
            background: linear-gradient(to bottom, #7b1fa2, #512da8);
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
        }
        
        .hide-fog-btn:hover {
            background: rgba(123, 31, 162, 0.9);
        }
        
        /* éæ˜ç¤ºæ ¼å­æ ·å¼ */
        .tile.fog {
            background: rgba(30, 30, 30, 0.8) !important;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .tile.fog .tile-content,
        .tile.fog .tile-type {
            visibility: hidden;
        }
        
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .tile {
                /* è°ƒæ•´å°å±å¹•ä¸‹çš„æ ¼å­å¤§å° */
                width: 30px;
                height: 30px;
                font-size: 8px;
            }
            
            .tile-content {
                font-size: 9px;
                top: -5px;
            }
            
            .tile-type {
                font-size: 14px;
            }
            
            .start-container, .end-container {
                padding: 15px;
                max-width: 400px;
            }
            
            .tutorial-container {
                padding: 20px;
                max-width: 95%;
            }
            
            .tutorial-content {
                grid-template-columns: 1fr;
            }
            
            .tutorial-image {
                height: 150px;
            }
            
            .start-title, .end-title {
                font-size: 2.2rem;
            }
            
            .game-info {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            
            .control-buttons {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 600px) {
            .tile {
                /* è°ƒæ•´æ›´å°å±å¹•ä¸‹çš„æ ¼å­å¤§å° */
                width: 25px;
                height: 25px;
            }
            
            .tile-type {
                font-size: 12px;
            }
            
            .tile-content {
                font-size: 8px;
                top: -4px;
            }
            
            .game-info span {
                font-size: 1rem;
                padding: 6px 10px;
                min-width: 100px;
            }
            
            .ai-controls {
                grid-template-columns: 1fr;
            }
            
            .start-container, .end-container {
                padding: 12px;
                max-width: 320px;
            }
            
            .tutorial-container {
                padding: 15px;
            }
            
            .tutorial-step {
                padding: 15px;
            }
            
            .tutorial-step h3 {
                font-size: 1.2rem;
            }
            
            .tutorial-step p {
                font-size: 0.95rem;
            }
            
            .start-title, .end-title {
                font-size: 1.8rem;
            }
            
            .size-option, .ai-count-option {
                padding: 10px;
            }
            
            .size-option h3, .ai-count-option h3 {
                font-size: 1.2rem;
            }
            
            .start-button, .restart-button, .tutorial-button {
                padding: 8px 20px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- æ•™ç¨‹ç•Œé¢ -->
    <div id="tutorial-screen">
        <div class="tutorial-container">
            <h1 class="tutorial-title">Generals IO æ¸¸æˆæ•™ç¨‹</h1>
            <p>å­¦ä¹ å¦‚ä½•å¾æœé¢†åœŸï¼Œå‡»è´¥AIæœºå™¨äººï¼Œæˆä¸ºæˆ˜åœºçš„ä¸»å®°ï¼</p>
            
            <div class="tutorial-content">
                <div class="tutorial-step">
                    <h3><span class="step-number">1</span>åŸºæœ¬ç›®æ ‡</h3>
                    <p>å é¢†åœ°å›¾ä¸Šçš„æ‰€æœ‰é¢†åœŸï¼Œå‡»è´¥æ‰€æœ‰AIå¯¹æ‰‹ã€‚ä½ çš„é¦–éƒ½ï¼ˆğŸ‘‘ï¼‰æ˜¯æ ¸å¿ƒï¼Œå¤±å»å®ƒæ„å‘³ç€å¤±è´¥ã€‚</p>
                    <div class="tutorial-image">
                        <div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;color:#ccc;font-size:1.2rem;">
                            ğŸ‘‘ ä½ çš„é¦–éƒ½
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="step-number">2</span>å•ä½ä¸ç§»åŠ¨</h3>
                    <p>ç‚¹å‡»ä½ çš„å•ä½ï¼ˆè“è‰²æ ¼å­ï¼‰ï¼Œç„¶åç‚¹å‡»æ–¹å‘æŒ‰é’®æˆ–ä½¿ç”¨WASDé”®ç§»åŠ¨ã€‚æ¯ä¸ªåŠå›åˆå•ä½åªèƒ½ç§»åŠ¨ä¸€æ¬¡ã€‚</p>
                    <div class="tutorial-image">
                        <div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;color:#ccc;font-size:1.2rem;">
                            <div style="text-align:center;">
                                <div style="margin-bottom:5px;">â¬†ï¸ åŒ— (W)</div>
                                <div style="display:flex;gap:10px;">
                                    <div>â¬…ï¸ è¥¿ (A)</div>
                                    <div style="margin:0 15px;">â¬‡ï¸ å— (S)</div>
                                    <div>â¡ï¸ ä¸œ (D)</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="step-number">3</span>åœ°å½¢ç±»å‹</h3>
                    <p>â›°ï¸ å±±åœ°ä¸å¯é€šè¿‡ï¼ŒğŸ° è¦å¡æœ‰é¢å¤–é˜²å¾¡ï¼ŒğŸŒŠ æ²¼æ³½ä¼šå‡å°‘å•ä½æ•°é‡ã€‚å é¢†è¦å¡å¯è·å¾—æˆ˜ç•¥ä¼˜åŠ¿ã€‚</p>
                    <div class="tutorial-image">
                        <div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;color:#ccc;font-size:1.2rem;gap:15px;">
                            <div>â›°ï¸</div>
                            <div>ğŸ°</div>
                            <div>ğŸŒŠ</div>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="step-number">4</span>æˆ˜äº‰è¿·é›¾</h3>
                    <p>åœ°å›¾ä¸Šæœ‰æˆ˜äº‰è¿·é›¾ï¼Œä½ åªèƒ½çœ‹åˆ°è‡ªå·±é¢†åœŸå‘¨å›´çš„åŒºåŸŸã€‚ä½¿ç”¨"æ˜¾ç¤ºæ‰€æœ‰æ ¼å­"æŒ‰é’®å¯ä»¥åˆ‡æ¢è¿·é›¾æ˜¾ç¤ºã€‚</p>
                    <div class="tutorial-image">
                        <div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;color:#ccc;font-size:1.2rem;">
                            <div style="background:rgba(30,30,30,0.8);padding:10px;border-radius:5px;">æˆ˜äº‰è¿·é›¾åŒºåŸŸ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tutorial-buttons">
                <button class="tutorial-button" id="tutorial-start-button">å¼€å§‹æ¸¸æˆ</button>
                <button class="tutorial-button skip" id="tutorial-skip-button">è·³è¿‡æ•™ç¨‹</button>
            </div>
        </div>
    </div>
    
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <div class="start-container">
            <h1 class="start-title">Generals IO</h1>
            <p>å¾æœé¢†åœŸï¼Œå‡»è´¥AIæœºå™¨äººï¼Œæˆä¸ºæˆ˜åœºçš„ä¸»å®°ï¼</p>
            
            <div class="map-size-selector">
                <div class="size-option selected" data-size="10">
                    <h3>å°å‹åœ°å›¾ (10Ã—10)</h3>
                    <p>å¿«é€Ÿæˆ˜æ–—ï¼Œé€‚åˆæ–°æ‰‹å…¥é—¨</p>
                </div>
                <div class="size-option" data-size="15">
                    <h3>ä¸­å‹åœ°å›¾ (15Ã—15)</h3>
                    <p>å¹³è¡¡çš„æ¸¸æˆä½“éªŒï¼Œæ¨èé€‰æ‹©</p>
                </div>
                <div class="size-option" data-size="20">
                    <h3>å¤§å‹åœ°å›¾ (20Ã—20)</h3>
                    <p>å²è¯—çº§æˆ˜æ–—ï¼ŒæŒ‘æˆ˜ç­–ç•¥æé™</p>
                </div>
            </div>
            
            <div class="ai-count-selector">
                <div class="ai-count-option selected" data-count="1">
                    <h3>1åAIå¯¹æ‰‹</h3>
                    <p>ç®€å•éš¾åº¦ï¼Œé€‚åˆåˆå­¦è€…</p>
                </div>
                <div class="ai-count-option" data-count="2">
                    <h3>2åAIå¯¹æ‰‹</h3>
                    <p>ä¸­ç­‰éš¾åº¦ï¼ŒæŒ‘æˆ˜ç­–ç•¥</p>
                </div>
                <div class="ai-count-option" data-count="3">
                    <h3>3åAIå¯¹æ‰‹</h3>
                    <p>å›°éš¾éš¾åº¦ï¼Œé«˜æ‰‹å¯¹å†³</p>
                </div>
            </div>
            
            <button class="start-button" id="start-button">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </div>
    
    <!-- ç»“æŸç•Œé¢ -->
    <div id="end-screen">
        <div class="end-container">
            <h1 class="end-title victory" id="end-title">èƒœåˆ©ï¼</h1>
            <p class="end-message" id="end-message">ä½ æˆåŠŸå¾æœäº†æ‰€æœ‰é¢†åœŸï¼</p>
            <button class="restart-button" id="restart-button">å†æ¥ä¸€å±€</button>
        </div>
    </div>
    
    <div class="container">
        <header>
            <h1>Generals IO ç½‘é¡µç‰ˆ</h1>
            <p>ç­–ç•¥å¾æœæ¸¸æˆ - å é¢†é¢†åœŸï¼Œå‡»è´¥AIæœºå™¨äººï¼</p>
            <div class="game-info">
                <span>åŠå›åˆ: <span id="halfturn">0</span></span>
                <span>è½®æ¬¡: <span id="round">0</span></span>
                <span>å½“å‰ç©å®¶: <span id="current-player">1</span></span>
            </div>
            <div class="game-state-indicator">
                <div class="state-dot auto" id="state-dot"></div>
                <span id="state-text">è‡ªåŠ¨æ¨¡å¼è¿è¡Œä¸­</span>
            </div>
        </header>
        
        <div class="game-area">
            <div class="map-container">
                <h2>æ¸¸æˆåœ°å›¾</h2>
                <div class="game-map" id="game-map"></div>
            </div>
            
            <div class="panel">
                <h2>æ¸¸æˆæ§åˆ¶</h2>
                <div class="control-buttons">
                    <button id="tick-btn">æ‰§è¡ŒåŠå›åˆ (Tick)</button>
                    <button id="clear-btn">æ¸…ç©ºé˜Ÿåˆ—</button>
                    <button id="auto-btn">å…³é—­è‡ªåŠ¨</button>
                </div>
                
                <div class="direction-controls">
                    <div class="dir-btn north" data-dir="n">åŒ— (N)</div>
                    <div class="dir-btn south" data-dir="s">å— (S)</div>
                    <div class="dir-btn west" data-dir="w">è¥¿ (W)</div>
                    <div class="dir-btn east" data-dir="e">ä¸œ (E)</div>
                </div>
                
                <div class="key-hint">
                    <p>é”®ç›˜æ§åˆ¶: W (åŒ—), A (è¥¿), S (å—), D (ä¸œ)</p>
                    <p>é€‰æ‹©æ ¼å­åï¼ŒæŒ‰æ–¹å‘é”®ç§»åŠ¨å•ä½</p>
                </div>
                
                <div class="hide-fog-btn active" id="hide-fog-btn">æ˜¾ç¤ºæ‰€æœ‰æ ¼å­</div>
                
                <div class="ai-controls">
                    <div class="ai-control-btn" id="gathering-btn">é›†ç»“å…µåŠ›</div>
                    <div class="ai-control-btn" id="target-btn">æ”»å‡»ç›®æ ‡</div>
                    <div class="ai-control-btn" id="aimove-btn">AIç§»åŠ¨</div>
                </div>
                
                <div class="color-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>ç©å®¶ 1</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>AIæœºå™¨äºº</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #95a5a6;"></div>
                        <span>ä¸­ç«‹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2c3e50;"></div>
                        <span>å±±åŒº</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8e44ad;"></div>
                        <span>è¦å¡</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #16a085;"></div>
                        <span>æ²¼æ³½</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8c00;"></div>
                        <span>AIé›†ç»“ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #333;"></div>
                        <span>æˆ˜äº‰è¿·é›¾</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="panel">
                <h2>æ¸¸æˆæ¶ˆæ¯</h2>
                <div class="messages" id="messages"></div>
            </div>
            
            <div class="panel">
                <h2>é˜Ÿä¼æ’å</h2>
                <div class="leaderboard" id="leaderboard"></div>
                
                <!-- å°†AIä¿¡æ¯æ ç§»åŠ¨åˆ°è¿™é‡Œ -->
                <div class="ai-info-panel" id="ai-info">
                    <strong>AIç­–ç•¥ä¿¡æ¯</strong>
                    <div id="ai-status">ç­‰å¾…æ¸¸æˆå¼€å§‹</div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot gathering-dot"></div>
                        <span id="gathering-status">é›†ç»“å…µåŠ›: å…³é—­</span>
                    </div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot target-dot"></div>
                        <span id="target-status">æ”»å‡»ç›®æ ‡: å…³é—­</span>
                    </div>
                    <div class="ai-status-line">
                        <div class="ai-status-dot ai-move-dot"></div>
                        <span id="aimove-status">AIç§»åŠ¨: å…³é—­</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆå¸¸é‡
        const TileType = {
            UNKNOWN: 0,
            MOUNTAIN: 1,
            STRONGHOLD: 2,
            PLAIN: 3,
            CAPITAL: 4,
            SWAMP: 5
        };
        
        const Direction = {
            NORTH: 0,  // U
            SOUTH: 1,  // D
            WEST: 2,   // L
            EAST: 3    // R
        };
        
        const DIRECTION_DELTAS = {
            [Direction.NORTH]: [0, -1],
            [Direction.SOUTH]: [0, 1],
            [Direction.WEST]: [-1, 0],
            [Direction.EAST]: [1, 0]
        };
        
        // ç©å®¶é¢œè‰²æ˜ å°„
        const PLAYER_COLORS = {
            0: "#95a5a6",  // ä¸­ç«‹ - ç°è‰²
            1: "#3498db",  // ç©å®¶1 - è“è‰²
            2: "#e74c3c",  // ç©å®¶2 - çº¢è‰²
            3: "#2ecc71",  // ç©å®¶3 - ç»¿è‰²
            4: "#f1c40f"   // ç©å®¶4 - é»„è‰²
        };
        
        // åœ°å½¢é¢œè‰²
        const TERRAIN_COLORS = {
            [TileType.MOUNTAIN]: "#2c3e50",
            [TileType.STRONGHOLD]: "#8e44ad",
            [TileType.PLAIN]: "#27ae60",
            [TileType.CAPITAL]: "#d35400",
            [TileType.SWAMP]: "#16a085",
            GATHERING: "#ff8c00" // AIé›†ç»“ç‚¹é¢œè‰²
        };
        
        // åœ°å½¢ç¬¦å·
        const TERRAIN_SYMBOLS = {
            [TileType.MOUNTAIN]: "â›°ï¸",
            [TileType.STRONGHOLD]: "ğŸ°",
            [TileType.PLAIN]: "â¬œ",
            [TileType.CAPITAL]: "ğŸ‘‘",
            [TileType.SWAMP]: "ğŸŒŠ"
        };
        
        class Player {
            constructor(id, teamId, capital) {
                this.id = id;
                this.teamId = teamId;
                this.capital = capital;
                this.isDefeated = false;
                this.isOffline = false;
                this.orderQueue = [];
                // æ·»åŠ ä½ç½®è®°å¿†
                this.lastPositions = new Map(); // å­˜å‚¨æ¯ä¸ªå•ä½çš„ä¸Šæ¬¡ä½ç½® {tileKey: {x, y}}
            }
        }
        
        class Tile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.type = TileType.PLAIN;
                this.ownerId = 0;  // 0 for neutral
                this.units = 0;
                this.lighten = false;
                // æ·»åŠ å†·å´æ—¶é—´å’Œä¸Šä¸€æ­¥ä½ç½®
                this.lastMoved = -100; // ä¸Šä¸€æ¬¡ç§»åŠ¨çš„åŠå›åˆè®¡æ•°
                this.lastPosition = null; // ä¸Šä¸€æ¬¡çš„ä½ç½® {x, y}
                // AIå¯è§†åŒ–çŠ¶æ€
                this.aiState = null; // 'gathering', 'target', 'ai-move'
                // æ˜ç¤ºçŠ¶æ€
                this.visible = false;
            }
            
            isPassable() {
                return this.type !== TileType.MOUNTAIN;
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨å†·å´ä¸­
            isInCooldown(halfturnCount) {
                return halfturnCount - this.lastMoved < 3;
            }
        }
        
        class GeneralsGame {
            constructor(width = 10, height = 10) {
                this.width = width;
                this.height = height;
                this.map = this.createMap(width, height);
                this.players = {};
                this.teams = {};
                this.playerMovePriority = [];
                this.currentPriorityIndex = 0;
                this.halfturnCount = 0;
                this.roundCount = 0;
                this.gameState = {
                    halfturnId: 0,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                this.initNeutralTeam();
                this.selectedTile = null;
                this.autoMode = true; // é»˜è®¤å¼€å¯è‡ªåŠ¨æ¨¡å¼
                this.gameOver = false;
                this.winner = null;
                this.aiStatus = "ç­‰å¾…æ¸¸æˆå¼€å§‹";
                this.aiCount = 1; // é»˜è®¤AIæ•°é‡
                this.hideFog = true; // é»˜è®¤éšè—éæ˜ç¤ºæ ¼å­
            }
            
            createMap(width, height) {
                const map = [];
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(new Tile(x, y));
                    }
                    map.push(row);
                }
                return map;
            }
            
            initNeutralTeam() {
                this.teams[0] = {
                    id: 0,
                    players: [],
                    visionCache: new Set()
                };
            }
            
            addPlayer(playerId, teamId, capitalX, capitalY) {
                if (this.players[playerId]) {
                    throw new Error(`ç©å®¶ ${playerId} å·²å­˜åœ¨`);
                }
                
                // åˆ›å»ºç©å®¶
                const player = new Player(playerId, teamId, { x: capitalX, y: capitalY });
                this.players[playerId] = player;
                
                // åˆ›å»ºé˜Ÿä¼ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                if (!this.teams[teamId]) {
                    this.teams[teamId] = {
                        id: teamId,
                        players: [],
                        visionCache: new Set()
                    };
                }
                this.teams[teamId].players.push(player);
                
                // åˆå§‹åŒ–ç©å®¶é¦–éƒ½ - è®¾ç½®ä¸º5å…µåŠ›
                const capitalTile = this.map[capitalY][capitalX];
                capitalTile.type = TileType.CAPITAL;
                capitalTile.ownerId = playerId;
                capitalTile.units = 5; // ä¿®æ”¹ï¼šåˆå§‹å…µåŠ›è®¾ç½®ä¸º5
                capitalTile.lighten = true;
                
                // æ›´æ–°ä¼˜å…ˆçº§é˜Ÿåˆ—
                this.playerMovePriority.push(playerId);
                
                return player;
            }
            
            // æ£€æŸ¥åœ°å›¾è¿é€šæ€§
            isMapConnected() {
                const visited = Array(this.height).fill().map(() => Array(this.width).fill(false));
                let regions = 0;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (!visited[y][x] && this.map[y][x].isPassable()) {
                            regions++;
                            if (regions > 1) {
                                return false; // å‘ç°å¤šä¸ªè¿é€šåŒºåŸŸï¼Œä¸è¿é€š
                            }
                            this.floodFill(x, y, visited);
                        }
                    }
                }
                return true;
            }
            
            floodFill(x, y, visited) {
                const queue = [{x, y}];
                visited[y][x] = true;
                
                while (queue.length > 0) {
                    const {x, y} = queue.shift();
                    
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            const tile = this.map[ny][nx];
                            if (!visited[ny][nx] && tile.isPassable()) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                }
            }
            
            // æ›´æ–°æ‰€æœ‰æ ¼å­çš„å¯è§æ€§
            updateVisibility() {
                // é‡ç½®æ‰€æœ‰æ ¼å­çš„å¯è§æ€§
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.map[y][x].visible = false;
                    }
                }
                
                // è®¾ç½®ç©å®¶é¢†åœ°åŠå…¶å‘¨å›´3x3åŒºåŸŸçš„å¯è§æ€§
                for (const playerId in this.players) {
                    if (playerId === "1") { // åªå¤„ç†äººç±»ç©å®¶
                        for (let y = 0; y < this.height; y++) {
                            for (let x = 0; x < this.width; x++) {
                                const tile = this.map[y][x];
                                if (tile.ownerId == playerId) {
                                    // è®¾ç½®è¯¥æ ¼å­å’Œå‘¨å›´3x3åŒºåŸŸä¸ºå¯è§
                                    for (let dy = -1; dy <= 1; dy++) {
                                        for (let dx = -1; dx <= 1; dx++) {
                                            const nx = x + dx;
                                            const ny = y + dy;
                                            if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                                                this.map[ny][nx].visible = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            appendOrder(playerId, srcX, srcY, direction, moveHalf) {
                if (!this.players[playerId]) return;
                
                const player = this.players[playerId];
                if (player.isDefeated || player.isOffline) return;
                
                player.orderQueue.push({
                    playerId,
                    srcX,
                    srcY,
                    direction,
                    moveHalf
                });
            }
            
            clearQueue(playerId) {
                if (this.players[playerId]) {
                    this.players[playerId].orderQueue = [];
                }
            }
            
            toggleAutoMode() {
                this.autoMode = !this.autoMode;
                return this.autoMode;
            }
            
            toggleFogVisibility() {
                this.hideFog = !this.hideFog;
                return this.hideFog;
            }
            
            tick() {
                if (this.gameOver) return this.gameState;
                
                this.halfturnCount++;
                this.gameState = {
                    halfturnId: this.halfturnCount,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                
                // æ¸…é™¤æ‰€æœ‰AIå¯è§†åŒ–çŠ¶æ€
                this.clearAIStates();
                
                // æ›´æ–°å¯è§æ€§
                this.updateVisibility();
                
                // ä¸ºæœºå™¨äººç©å®¶ç”Ÿæˆç§»åŠ¨æŒ‡ä»¤
                this.generateRobotOrders();
                
                // å¾ªç¯æ‰§è¡Œæ‰€æœ‰ç©å®¶çš„æŒ‡ä»¤é˜Ÿåˆ—
                let processedOrders = [];
                let maxLoops = this.width * this.height; // é˜²æ­¢æ­»å¾ªç¯
                let hasOrders = true;
                
                // åˆ›å»ºç©å®¶é¡ºåºåˆ—è¡¨ï¼ˆä»å½“å‰ä¼˜å…ˆçº§å¼€å§‹ï¼‰
                let playerOrder = [];
                if (this.playerMovePriority.length > 0) {
                    playerOrder = [
                        ...this.playerMovePriority.slice(this.currentPriorityIndex),
                        ...this.playerMovePriority.slice(0, this.currentPriorityIndex)
                    ];
                    // æ›´æ–°ä¸‹ä¸€ä¸ªtickçš„èµ·å§‹ç©å®¶
                    this.currentPriorityIndex = (this.currentPriorityIndex + 1) % this.playerMovePriority.length;
                }
                
                while (hasOrders && maxLoops-- > 0) {
                    hasOrders = false;
                    
                    // æŒ‰é¡ºåºå¤„ç†æ¯ä¸ªç©å®¶çš„ä¸€ä¸ªæŒ‡ä»¤
                    for (let i = 0; i < playerOrder.length; i++) {
                        const playerId = playerOrder[i];
                        const player = this.players[playerId];
                        
                        if (!player || player.isDefeated || player.isOffline) continue;
                        
                        if (player.orderQueue.length > 0) {
                            hasOrders = true;
                            const order = player.orderQueue.shift();
                            if (this.processMoveOrder(order)) {
                                processedOrders.push(order);
                            }
                        }
                    }
                }
                
                // å•ä½ç”Ÿæˆä¸æ¶ˆå¤±
                this.generateUnits();
                
                // æ›´æ–°å­˜æ´»ç©å®¶åˆ—è¡¨
                this.gameState.alivePlayers = Object.keys(this.players)
                    .filter(playerId => {
                        const player = this.players[playerId];
                        return !player.isDefeated && !player.isOffline;
                    });
                
                // å¢åŠ è½®æ¬¡è®¡æ•°
                if (this.halfturnCount % 50 === 0) {
                    this.roundCount++;
                }
                
                // ç”Ÿæˆæ¨¡æ‹Ÿæ¶ˆæ¯
                if (this.halfturnCount % 5 === 0) {
                    this.gameState.messages.push(`åŠå›åˆ ${this.halfturnCount} å®Œæˆ`);
                }
                
                // ç”Ÿæˆæ¨¡æ‹Ÿæ’è¡Œæ¦œ
                this.updateLeaderboard();
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                this.checkGameEnd();
                
                return this.gameState;
            }
            
            // æ¸…é™¤æ‰€æœ‰AIå¯è§†åŒ–çŠ¶æ€
            clearAIStates() {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.map[y][x].aiState = null;
                    }
                }
            }
            
            // ä¼˜åŒ–åçš„æœºå™¨äººAIç­–ç•¥ - ä¿®æ”¹ï¼šä½¿ä¸åŒAIä¹‹é—´äº’ç›¸æ”»å‡»
            generateRobotOrders() {
                for (let aiId = 2; aiId <= 1 + this.aiCount; aiId++) {
                    const robotPlayerId = aiId;
                    const robot = this.players[robotPlayerId];
                    
                    if (!robot || robot.isDefeated || robot.isOffline) continue;
                    
                    // æ ‡è®°æ˜¯å¦å·²ç”ŸæˆæŒ‡ä»¤
                    let orderGenerated = false;
                    
                    // ç­–ç•¥1: é€ƒç¦»æ²¼æ³½ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
                    const swampTiles = this.findSwampTiles(robotPlayerId);
                    if (swampTiles.length > 0) {
                        // å°è¯•æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰è¶³å¤Ÿå•ä½å¯ä»¥ç§»åŠ¨çš„æ²¼æ³½åœ°å—
                        for (const tile of swampTiles) {
                            if (tile.units > 1) {
                                this.executeSwampEscapeStrategy(tile, robotPlayerId);
                                orderGenerated = true;
                                break;
                            }
                        }
                    }
                    
                    // å¦‚æœå°šæœªç”ŸæˆæŒ‡ä»¤ï¼Œå°è¯•ç­–ç•¥2: è¿›æ”»ç©å®¶é¢†åœ°æˆ–ä¸­ç«‹è¦å¡
                    if (!orderGenerated) {
                        const attackTarget = this.findAttackTarget(robotPlayerId);
                        if (attackTarget) {
                            // ä½¿ç”¨æ”¹è¿›çš„æ”»å‡»ç­–ç•¥ï¼ˆæ”¯æŒå…µåŠ›é›†ç»“ï¼‰
                            this.executeAdvancedAttackStrategy(attackTarget.srcTile, attackTarget.targetTile, robotPlayerId);
                            orderGenerated = true;
                        }
                    }
                    
                    // ç­–ç•¥3: å‘å››å‘¨æ‰©å¼ ä¸­æ€§åœŸåœ°
                    if (!orderGenerated) {
                        const expansionTarget = this.findNeutralExpansion(robotPlayerId);
                        if (expansionTarget) {
                            const dir = this.getDirection(expansionTarget.srcTile, expansionTarget.destTile);
                            if (dir !== null) {
                                this.players[robotPlayerId].orderQueue.push({
                                    playerId: robotPlayerId,
                                    srcX: expansionTarget.srcTile.x,
                                    srcY: expansionTarget.srcTile.y,
                                    direction: dir,
                                    moveHalf: false
                                });
                                this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} å‘ä¸­æ€§åœŸåœ°(${expansionTarget.destTile.x},${expansionTarget.destTile.y})æ‰©å¼ `);
                                orderGenerated = true;
                            }
                        }
                    }
                    
                    // ç­–ç•¥4: å‘å…¶ä»–AIé¦–éƒ½æ–¹å‘æ‰©å¼ 
                    if (!orderGenerated) {
                        // æŸ¥æ‰¾å…¶ä»–AIçš„é¦–éƒ½
                        const otherAICapitals = [];
                        for (let otherId = 2; otherId <= 1 + this.aiCount; otherId++) {
                            if (otherId !== robotPlayerId) {
                                const otherAI = this.players[otherId];
                                if (otherAI && !otherAI.isDefeated) {
                                    otherAICapitals.push(otherAI.capital);
                                }
                            }
                        }
                        
                        if (otherAICapitals.length > 0) {
                            // éšæœºé€‰æ‹©ä¸€ä¸ªå…¶ä»–AIçš„é¦–éƒ½ä½œä¸ºç›®æ ‡
                            const targetCapital = otherAICapitals[Math.floor(Math.random() * otherAICapitals.length)];
                            const expansionTarget = this.findExpansionTarget(robotPlayerId, targetCapital);
                            if (expansionTarget) {
                                this.executeExpansionStrategy(expansionTarget, targetCapital, robotPlayerId);
                                orderGenerated = true;
                            }
                        }
                    }
                    
                    // ç­–ç•¥5: éšæœºç§»åŠ¨
                    if (!orderGenerated) {
                        this.executeRandomStrategy(robotPlayerId);
                    }
                }
            }
            
            // æŸ¥æ‰¾æ”»å‡»ç›®æ ‡ - ä¿®æ”¹ï¼šä½¿AIä¹Ÿä¼šæ”»å‡»å…¶ä»–AI
            findAttackTarget(robotPlayerId) {
                const humanPlayerId = 1;
                let bestSource = null;
                let bestTarget = null;
                let bestScore = -Infinity;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const srcTile = this.map[y][x];
                        if (srcTile.ownerId !== robotPlayerId || srcTile.units <= 1) continue;
                        
                        for (const dir of Object.values(Direction)) {
                            const [dx, dy] = DIRECTION_DELTAS[dir];
                            const destX = x + dx;
                            const destY = y + dy;
                            
                            if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                            
                            const destTile = this.map[destY][destX];
                            if (!destTile.isPassable()) continue;
                            
                            // è€ƒè™‘ç©å®¶æ§åˆ¶çš„æ ¼å­æˆ–ä¸­ç«‹è¦å¡ - ä¿®æ”¹ï¼šåŒ…æ‹¬å…¶ä»–AIç©å®¶
                            if ((destTile.ownerId !== 0 && destTile.ownerId !== robotPlayerId) || 
                                (destTile.ownerId === 0 && destTile.type === TileType.STRONGHOLD)) {
                                let score = 0;
                                
                                // ä¼˜å…ˆæ”»å‡»è¦å¡
                                if (destTile.type === TileType.STRONGHOLD) score += 30;
                                
                                // ä¼˜å…ˆæ”»å‡»é¦–éƒ½
                                if (destTile.type === TileType.CAPITAL) score += 50;
                                
                                // ä¼˜å…ˆæ”»å‡»å•ä½å°‘çš„æ ¼å­
                                score += 20 - destTile.units;
                                
                                // é¿å…æ²¼æ³½æ”»å‡»
                                if (srcTile.type === TileType.SWAMP) score -= 10;
                                
                                // å…µåŠ›ä¼˜åŠ¿
                                if (srcTile.units > destTile.units) {
                                    score += 20;
                                }
                                
                                // é™„è¿‘æ”¯æ´å…µåŠ›
                                const supportUnits = this.findNearbySupportUnits(srcTile, destTile, robotPlayerId);
                                if (supportUnits > destTile.units) {
                                    score += 15;
                                }
                                
                                // å¦‚æœæ˜¯ä¸­ç«‹è¦å¡ï¼Œé¢å¤–åŠ åˆ†
                                if (destTile.ownerId === 0 && destTile.type === TileType.STRONGHOLD) {
                                    score += 20;
                                }
                                
                                // å¦‚æœæ˜¯AIç©å®¶ï¼Œæ ¹æ®å¨èƒç¨‹åº¦è°ƒæ•´åˆ†æ•°
                                if (destTile.ownerId >= 2 && destTile.ownerId <= 4) {
                                    score += 25; // é¼“åŠ±AIä¹‹é—´äº’ç›¸æ”»å‡»
                                }
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestSource = srcTile;
                                    bestTarget = destTile;
                                }
                            }
                        }
                    }
                }
                
                return bestSource ? { srcTile: bestSource, targetTile: bestTarget } : null;
            }
            
            // æ‰§è¡Œé«˜çº§æ”»å‡»ç­–ç•¥ï¼ˆæ”¯æŒå…µåŠ›é›†ç»“ï¼‰
            executeAdvancedAttackStrategy(srcTile, targetTile, robotPlayerId) {
                // è®¡ç®—æ”»å‡»æ‰€éœ€å…µåŠ›ï¼ˆç›®æ ‡å…µåŠ›+1ï¼‰
                const requiredUnits = targetTile.units + 1;
                this.aiStatus = `ç©å®¶${robotPlayerId}å‘ç°ç›®æ ‡: (${targetTile.x},${targetTile.y}) éœ€è¦å…µåŠ›: ${requiredUnits}`;
                
                // å¦‚æœå½“å‰å…µåŠ›è¶³å¤Ÿï¼Œç›´æ¥æ”»å‡»
                if (srcTile.units > requiredUnits) {
                    this.aiStatus = `ç©å®¶${robotPlayerId}å…µåŠ›å……è¶³ï¼Œç›´æ¥æ”»å‡»ç›®æ ‡ (${targetTile.x},${targetTile.y})`;
                    this.executeAttackStrategy(srcTile, targetTile, robotPlayerId);
                    return;
                }
                
                this.aiStatus = `ç©å®¶${robotPlayerId}å…µåŠ›ä¸è¶³ï¼Œå¼€å§‹é›†ç»“ (${srcTile.units}/${requiredUnits})`;
                
                // å…µåŠ›ä¸è¶³ï¼Œå°è¯•é›†ç»“å…µåŠ›
                const gatherResult = this.gatherForces(srcTile, targetTile, robotPlayerId, requiredUnits);
                
                if (gatherResult.success) {
                    // æˆåŠŸé›†ç»“ï¼Œæ·»åŠ æ”»å‡»æŒ‡ä»¤
                    const path = this.bfsPath(srcTile.x, srcTile.y, targetTile.x, targetTile.y, robotPlayerId);
                    
                    if (path && path.length > 1) {
                        const nextStep = path[1];
                        const dir = this.getDirection({x: path[0].x, y: path[0].y}, nextStep);
                        
                        if (dir !== null) {
                            this.players[robotPlayerId].orderQueue.push({
                                playerId: robotPlayerId,
                                srcX: srcTile.x,
                                srcY: srcTile.y,
                                direction: dir,
                                moveHalf: false
                            });
                            
                            // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                            srcTile.aiState = 'ai-move';
                            targetTile.aiState = 'target';
                            
                            this.gameState.messages.push(
                                `æœºå™¨äººç©å®¶${robotPlayerId}é›†ç»“æˆåŠŸï¼ä»(${srcTile.x},${srcTile.y})å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨`
                            );
                        }
                    }
                } else {
                    // æ— æ³•é›†ç»“è¶³å¤Ÿå…µåŠ›ï¼Œæ‰§è¡ŒåŸæ”»å‡»ç­–ç•¥
                    this.aiStatus = `ç©å®¶${robotPlayerId}æ— æ³•é›†ç»“è¶³å¤Ÿå…µåŠ› (${gatherResult.totalUnits}/${requiredUnits})ï¼Œå°è¯•æ”»å‡»`;
                    this.executeAttackStrategy(srcTile, targetTile, robotPlayerId);
                }
            }
            
            // ä¼˜åŒ–å…µåŠ›é›†ç»“æ–¹æ³• - ä¼˜å…ˆä»å·±æ–¹å…µåŠ›æœ€å¤šçš„æ ¼å­è°ƒå…µï¼ˆå…µåŠ›ç›¸åŒåˆ™é€‰æ‹©æœ€è¿‘çš„ï¼‰
            gatherForces(gatheringPoint, targetTile, playerId, requiredUnits) {
                let totalGathered = gatheringPoint.units;
                const gatheringQueue = [];
                
                // 1. å¯»æ‰¾é™„è¿‘çš„å‹å†›å•ä½ï¼ˆ5æ ¼èŒƒå›´å†…ï¼‰
                const nearbyAllies = this.findNearbyAllies(gatheringPoint, playerId, 5);
                
                // 2. æ’åºè§„åˆ™ï¼šä¼˜å…ˆå…µåŠ›æœ€å¤šçš„æ ¼å­ï¼Œå…µåŠ›ç›¸åŒåˆ™é€‰æ‹©è·ç¦»æœ€è¿‘çš„
                nearbyAllies.sort((a, b) => {
                    // ä¸»è¦æŒ‰å…µåŠ›ä»å¤§åˆ°å°æ’åº
                    if (b.units !== a.units) {
                        return b.units - a.units;
                    }
                    // æ¬¡è¦æŒ‰è·ç¦»ä»å°åˆ°å¤§æ’åº
                    const distA = Math.abs(a.x - gatheringPoint.x) + Math.abs(a.y - gatheringPoint.y);
                    const distB = Math.abs(b.x - gatheringPoint.x) + Math.abs(b.y - gatheringPoint.y);
                    return distA - distB;
                });
                
                // 3. æŒ‡æŒ¥å‹å†›å‘é›†ç»“ç‚¹ç§»åŠ¨ï¼ˆåªé€‰æ‹©æœ€é‡è¦çš„ä¸€ä¸ªï¼‰
                if (nearbyAllies.length > 0) {
                    const ally = nearbyAllies[0];
                    if (ally.units > 1) {
                        // æ£€æŸ¥å†·å´æ—¶é—´
                        if (ally.isInCooldown(this.halfturnCount)) {
                            return {
                                success: false,
                                totalUnits: totalGathered
                            };
                        }
                        
                        // è®¡ç®—ç§»åŠ¨æ–¹å‘ï¼ˆä½¿ç”¨ä¼˜åŒ–è·¯å¾„ç®—æ³•ï¼‰
                        const path = this.optimizedBfsPath(ally.x, ally.y, gatheringPoint.x, gatheringPoint.y, playerId);
                        
                        if (path && path.length > 1) {
                            // åªç§»åŠ¨ç¬¬ä¸€æ­¥
                            const nextStep = path[1];
                            const dir = this.getDirection({x: ally.x, y: ally.y}, nextStep);
                            
                            if (dir !== null) {
                                // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦æœ‰æ•ˆ
                                if (this.isMoveValid(ally.x, ally.y, dir, playerId)) {
                                    gatheringQueue.push({
                                        playerId: playerId,
                                        srcX: ally.x,
                                        srcY: ally.y,
                                        direction: dir,
                                        moveHalf: false
                                    });
                                    
                                    // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                                    ally.aiState = 'gathering';
                                    gatheringPoint.aiState = 'gathering';
                                    targetTile.aiState = 'target';
                                    
                                    // è®¡ç®—å¯ç§»åŠ¨çš„å…µåŠ›ï¼ˆæœ€å¤šç§»åŠ¨å…¨éƒ¨-1ï¼‰
                                    const moveUnits = ally.units - 1;
                                    
                                    // æ›´æ–°ç»Ÿè®¡æ•°æ®
                                    totalGathered += moveUnits;
                                    
                                    this.gameState.messages.push(
                                        `æœºå™¨äººç©å®¶${playerId}é›†ç»“å…µåŠ›: ä»(${ally.x},${ally.y})ç§»åŠ¨${moveUnits}å•ä½åˆ°é›†ç»“ç‚¹(${gatheringPoint.x},${gatheringPoint.y})`
                                    );
                                }
                            }
                        }
                    }
                }
                
                // å°†é›†ç»“æŒ‡ä»¤æ·»åŠ åˆ°æœºå™¨äººé˜Ÿåˆ—
                gatheringQueue.forEach(order => {
                    this.players[playerId].orderQueue.push(order);
                });
                
                return {
                    success: totalGathered >= requiredUnits,
                    totalUnits: totalGathered
                };
            }
            
            // æ–°å¢ï¼šç§»åŠ¨æœ‰æ•ˆæ€§æ£€æŸ¥
            isMoveValid(srcX, srcY, direction, playerId) {
                const [dx, dy] = DIRECTION_DELTAS[direction];
                const destX = srcX + dx;
                const destY = srcY + dy;
                
                // è¾¹ç•Œæ£€æŸ¥
                if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) {
                    return false;
                }
                
                const srcTile = this.map[srcY][srcX];
                const destTile = this.map[destY][destX];
                
                // æºæ ¼å­éªŒè¯
                if (srcTile.ownerId !== playerId || srcTile.units <= 1) {
                    return false;
                }
                
                // ç›®æ ‡æ˜¯å¦å¯é€šè¿‡
                if (!destTile.isPassable()) {
                    return false;
                }
                
                // å†·å´æ—¶é—´æ£€æŸ¥
                if (srcTile.isInCooldown(this.halfturnCount)) {
                    return false;
                }
                
                return true;
            }
            
            // æ–°å¢ï¼šä¼˜åŒ–è·¯å¾„ç®—æ³•ï¼ˆé¿å…æ²¼æ³½ï¼‰
            optimizedBfsPath(startX, startY, targetX, targetY, playerId, maxDepth = 20) {
                const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
                const visited = new Set([`${startX},${startY}`]);
                
                while (queue.length > 0) {
                    const { x, y, path, cost } = queue.shift();
                    
                    // è¾¾åˆ°ç›®æ ‡
                    if (x === targetX && y === targetY) {
                        return [...path, { x, y }];
                    }
                    
                    // è¶…è¿‡æœ€å¤§æ·±åº¦
                    if (path.length >= maxDepth) continue;
                    
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        // è¾¹ç•Œæ£€æŸ¥
                        if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                        
                        const tile = this.map[ny][nx];
                        // è·³è¿‡å±±åœ°å’Œæ•Œæ–¹è¦å¡
                        if (!tile.isPassable() || 
                            (tile.type === TileType.STRONGHOLD && tile.ownerId !== playerId)) {
                            continue;
                        }
                        
                        const key = `${nx},${ny}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            
                            // è®¡ç®—ç§»åŠ¨æˆæœ¬ï¼ˆæ²¼æ³½æˆæœ¬æ›´é«˜ï¼‰
                            let moveCost = 1;
                            if (tile.type === TileType.SWAMP) {
                                moveCost = 3; // æ²¼æ³½åœ°å½¢æƒ©ç½š
                            }
                            
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...path, { x, y }],
                                cost: cost + moveCost
                            });
                        }
                    }
                    
                    // æŒ‰æˆæœ¬æ’åºé˜Ÿåˆ—
                    queue.sort((a, b) => a.cost - b.cost);
                }
                
                return null; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
            }
            
            // å¯»æ‰¾é™„è¿‘çš„å‹å†›å•ä½
            findNearbyAllies(centerTile, playerId, radius) {
                const allies = [];
                const minX = Math.max(0, centerTile.x - radius);
                const maxX = Math.min(this.width - 1, centerTile.x + radius);
                const minY = Math.max(0, centerTile.y - radius);
                const maxY = Math.min(this.height - 1, centerTile.y + radius);
                
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === playerId && tile.units > 0) {
                            allies.push(tile);
                        }
                    }
                }
                
                return allies;
            }
            
            // æ‰§è¡Œæ”»å‡»ç­–ç•¥
            executeAttackStrategy(srcTile, targetTile, robotPlayerId) {
                // ä½¿ç”¨BFSè®¡ç®—æœ€ä¼˜è·¯å¾„
                const path = this.bfsPath(srcTile.x, srcTile.y, targetTile.x, targetTile.y, robotPlayerId);
                
                if (path && path.length > 1) {
                    // è§„åˆ’æœªæ¥3å›åˆçš„ç§»åŠ¨
                    const steps = Math.min(3, path.length - 1);
                    
                    for (let i = 0; i < steps; i++) {
                        const nextStep = path[i + 1];
                        const dir = this.getDirection({x: path[i].x, y: path[i].y}, nextStep);
                        
                        if (dir !== null) {
                            // æ·»åŠ æŒ‡ä»¤åˆ°æœºå™¨äººé˜Ÿåˆ—
                            this.players[robotPlayerId].orderQueue.push({
                                playerId: robotPlayerId,
                                srcX: path[i].x,
                                srcY: path[i].y,
                                direction: dir,
                                moveHalf: false
                            });
                            
                            // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                            srcTile.aiState = 'ai-move';
                            targetTile.aiState = 'target';
                            
                            this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨: æ­¥éª¤ ${i+1}/${steps}`);
                        }
                    }
                } else {
                    // ç›´æ¥å‘ç›®æ ‡ç§»åŠ¨
                    const dir = this.getDirection(srcTile, targetTile);
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                        srcTile.aiState = 'ai-move';
                        targetTile.aiState = 'target';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} ç›´æ¥å‘ç›®æ ‡(${targetTile.x},${targetTile.y})ç§»åŠ¨`);
                    }
                }
            }
            
            // æŸ¥æ‰¾æ‰©å¼ ç›®æ ‡
            findExpansionTarget(robotPlayerId, humanCapital) {
                let bestTile = null;
                let minDistance = Infinity;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId !== robotPlayerId || tile.units <= 1) continue;
                        if (tile.type === TileType.SWAMP) continue; // è·³è¿‡æ²¼æ³½å•ä½
                        
                        const distance = Math.abs(x - humanCapital.x) + Math.abs(y - humanCapital.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestTile = tile;
                        }
                    }
                }
                
                return bestTile;
            }
            
            // æ‰§è¡Œæ‰©å¼ ç­–ç•¥
            executeExpansionStrategy(srcTile, humanCapital, robotPlayerId) {
                // ä½¿ç”¨BFSè®¡ç®—æœ€ä¼˜è·¯å¾„
                const path = this.bfsPath(srcTile.x, srcTile.y, humanCapital.x, humanCapital.y, robotPlayerId);
                
                if (path && path.length > 1) {
                    // åªç§»åŠ¨ç¬¬ä¸€æ­¥ï¼ˆä¿ç•™åç»­æ­¥éª¤ä¾›ä¸‹å›åˆå†³ç­–ï¼‰
                    const nextStep = path[1];
                    const dir = this.getDirection({x: path[0].x, y: path[0].y}, nextStep);
                    
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        // è®°å½•å½“å‰ä½ç½®ä¾›ä¸‹å›åˆä½¿ç”¨
                        const robot = this.players[robotPlayerId];
                        robot.lastPositions.set(`${srcTile.x},${srcTile.y}`, {
                            x: nextStep.x,
                            y: nextStep.y,
                            path: path.slice(1),
                            type: 'expansion'
                        });
                        
                        // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                        srcTile.aiState = 'ai-move';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} å‘ç›®æ ‡(${humanCapital.x},${humanCapital.y})ç§»åŠ¨`);
                    }
                } else {
                    // ç›´æ¥å‘é¦–éƒ½æ–¹å‘ç§»åŠ¨
                    const dir = this.getDirection(srcTile, humanCapital);
                    if (dir !== null) {
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: srcTile.x,
                            srcY: srcTile.y,
                            direction: dir,
                            moveHalf: false
                        });
                        
                        // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                        srcTile.aiState = 'ai-move';
                        
                        this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} ç›´æ¥å‘ç›®æ ‡(${humanCapital.x},${humanCapital.y})ç§»åŠ¨`);
                    }
                }
            }
            
            // æŸ¥æ‰¾æ²¼æ³½ä¸Šçš„å…µåŠ›
            findSwampTiles(robotPlayerId) {
                const tiles = [];
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === robotPlayerId && 
                            tile.type === TileType.SWAMP && 
                            tile.units > 0) {
                            tiles.push(tile);
                        }
                    }
                }
                return tiles;
            }
            
            // æ‰§è¡Œæ²¼æ³½é€ƒè„±ç­–ç•¥ï¼ˆä¼˜åŒ–ç‰ˆï¼‰- é¿å…åŸè·¯ã€ä¼˜å…ˆå¹³åŸã€ä¼˜å…ˆéå·±æ–¹
            executeSwampEscapeStrategy(tile, robotPlayerId) {
                // å¦‚æœå•ä½ä¸è¶³2ä¸ªï¼Œæ— æ³•ç§»åŠ¨
                if (tile.units <= 1) return;
                
                const directions = Object.values(Direction);
                const validDirections = [];
                
                for (const dir of directions) {
                    const [dx, dy] = DIRECTION_DELTAS[dir];
                    const destX = tile.x + dx;
                    const destY = tile.y + dy;
                    
                    if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                    
                    const destTile = this.map[destY][destX];
                    if (!destTile.isPassable()) continue;
                    
                    validDirections.push(dir);
                }
                
                if (validDirections.length > 0) {
                    // é€‰æ‹©æœ€ä½³æ–¹å‘ï¼ˆä¼˜å…ˆå¹³åŸï¼Œé¿å…æ–°æ²¼æ³½ï¼Œä¼˜å…ˆéå·±æ–¹ï¼Œé¿å…åŸè·¯è¿”å›ï¼‰
                    let bestDir = validDirections[0];
                    let bestScore = -Infinity;
                    
                    for (const dir of validDirections) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const destX = tile.x + dx;
                        const destY = tile.y + dy;
                        const destTile = this.map[destY][destX];
                        
                        let score = 0;
                        // åœ°å½¢ç±»å‹è¯„åˆ†
                        if (destTile.type === TileType.PLAIN) score += 20;
                        if (destTile.type === TileType.STRONGHOLD) score += 10;
                        if (destTile.type === TileType.SWAMP) score -= 30; // é¿å…æ–°æ²¼æ³½
                        
                        // é¢†åœ°æ‰€æœ‰æƒè¯„åˆ†
                        if (destTile.ownerId === robotPlayerId) {
                            score += 5; // å·±æ–¹é¢†åœ°
                        } else if (destTile.ownerId === 0) {
                            score += 15; // ä¸­ç«‹é¢†åœ°ï¼ˆä¼˜å…ˆå é¢†ï¼‰
                        } else {
                            score += 10; // æ•Œæ–¹é¢†åœ°ï¼ˆå¯ä»¥æ”»å‡»ï¼‰
                        }
                        
                        // é¿å…åŸè·¯è¿”å›
                        if (tile.lastPosition) {
                            if (destX === tile.lastPosition.x && destY === tile.lastPosition.y) {
                                score -= 50; // å¤§å¹…é™ä½è¿”å›åŸè·¯çš„è¯„åˆ†
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestDir = dir;
                        }
                    }
                    
                    // æ·»åŠ æŒ‡ä»¤åˆ°æœºå™¨äººé˜Ÿåˆ—
                    this.players[robotPlayerId].orderQueue.push({
                        playerId: robotPlayerId,
                        srcX: tile.x,
                        srcY: tile.y,
                        direction: bestDir,
                        moveHalf: false
                    });
                    
                    // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                    tile.aiState = 'ai-move';
                    
                    this.gameState.messages.push(`æœºå™¨äººç©å®¶ ${robotPlayerId} é€ƒç¦»æ²¼æ³½(${tile.x},${tile.y})ï¼Œæ–¹å‘: ${this.getDirectionName(bestDir)}`);
                }
            }
            
            // æŸ¥æ‰¾ä¸­æ€§åœŸåœ°æ‰©å¼ ç›®æ ‡
            findNeutralExpansion(robotPlayerId) {
                const expansionTargets = [];
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId !== robotPlayerId || tile.units <= 1) continue;
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘æ˜¯å¦æœ‰ä¸­æ€§åœŸåœ°
                        const directions = Object.values(Direction);
                        for (const dir of directions) {
                            const [dx, dy] = DIRECTION_DELTAS[dir];
                            const destX = x + dx;
                            const destY = y + dy;
                            
                            if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                            
                            const destTile = this.map[destY][destX];
                            // å¦‚æœç›®æ ‡åœ°å—æ˜¯ä¸­æ€§ä¸”å¯é€šè¿‡
                            if (destTile.ownerId === 0 && destTile.isPassable()) {
                                expansionTargets.push({
                                    srcTile: tile,
                                    destTile: destTile,
                                    score: destTile.units + (destTile.type === TileType.PLAIN ? 10 : 0)
                                });
                            }
                        }
                    }
                }
                
                // é€‰æ‹©æœ€ä½³æ‰©å¼ ç›®æ ‡ï¼ˆä¼˜å…ˆå•ä½å°‘çš„åœ°å—ï¼‰
                if (expansionTargets.length > 0) {
                    expansionTargets.sort((a, b) => a.score - b.score);
                    return expansionTargets[0];
                }
                
                return null;
            }
            
            // æ‰§è¡Œéšæœºç§»åŠ¨ç­–ç•¥ï¼ˆå¢åŠ æ‰©å¼ æƒé‡ï¼‰
            executeRandomStrategy(robotPlayerId) {
                const movableTiles = [];
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.map[y][x];
                        if (tile.ownerId === robotPlayerId && 
                            tile.units > 1) {
                            movableTiles.push(tile);
                        }
                    }
                }
                
                if (movableTiles.length > 0) {
                    const tile = movableTiles[Math.floor(Math.random() * movableTiles.length)];
                    const directions = Object.values(Direction);
                    const validDirections = [];
                    const directionScores = [];
                    
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const destX = tile.x + dx;
                        const destY = tile.y + dy;
                        
                        if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) continue;
                        
                        const destTile = this.map[destY][destX];
                        if (!destTile.isPassable()) continue;
                        if (destTile.type === TileType.SWAMP) continue;
                        
                        validDirections.push(dir);
                        
                        // ç»™æ‰©å¼ æ–¹å‘æ›´é«˜æƒé‡
                        let score = 1;
                        if (destTile.ownerId === 0) score += 3; // ä¸­æ€§åœŸåœ°
                        if (destTile.type === TileType.PLAIN) score += 2; // å¹³åŸ
                        directionScores.push(score);
                    }
                    
                    if (validDirections.length > 0) {
                        // æ ¹æ®åˆ†æ•°é€‰æ‹©æ–¹å‘
                        const totalScore = directionScores.reduce((a, b) => a + b, 0);
                        let randomScore = Math.random() * totalScore;
                        
                        let selectedDir = validDirections[0];
                        for (let i = 0; i < validDirections.length; i++) {
                            randomScore -= directionScores[i];
                            if (randomScore <= 0) {
                                selectedDir = validDirections[i];
                                break;
                            }
                        }
                        
                        this.players[robotPlayerId].orderQueue.push({
                            playerId: robotPlayerId,
                            srcX: tile.x,
                            srcY: tile.y,
                            direction: selectedDir,
                            moveHalf: Math.random() > 0.5
                        });
                        
                        // è®¾ç½®AIå¯è§†åŒ–çŠ¶æ€
                        tile.aiState = 'ai-move';
                    }
                }
            }
            
            // BFSè·¯å¾„æŸ¥æ‰¾
            bfsPath(startX, startY, targetX, targetY, playerId, maxDepth = 20) {
                const queue = [{ x: startX, y: startY, path: [] }];
                const visited = new Set([`${startX},${startY}`]);
                
                while (queue.length > 0) {
                    const { x, y, path } = queue.shift();
                    
                    // è¾¾åˆ°ç›®æ ‡
                    if (x === targetX && y === targetY) {
                        return [...path, { x, y }];
                    }
                    
                    // è¶…è¿‡æœ€å¤§æ·±åº¦
                    if (path.length >= maxDepth) continue;
                    
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘
                    const directions = Object.values(Direction);
                    for (const dir of directions) {
                        const [dx, dy] = DIRECTION_DELTAS[dir];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        // è¾¹ç•Œæ£€æŸ¥
                        if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                        
                        const tile = this.map[ny][nx];
                        // è·³è¿‡å±±åœ°å’Œæ•Œæ–¹è¦å¡
                        if (!tile.isPassable() || 
                            (tile.type === TileType.STRONGHOLD && tile.ownerId !== playerId)) {
                            continue;
                        }
                        
                        const key = `${nx},${ny}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...path, { x, y }]
                            });
                        }
                    }
                }
                
                return null; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
            }
            
            // è·å–æ–¹å‘
            getDirection(srcTile, destTile) {
                const dx = destTile.x - srcTile.x;
                const dy = destTile.y - srcTile.y;
                
                if (dx === 1 && dy === 0) return Direction.EAST;
                if (dx === -1 && dy === 0) return Direction.WEST;
                if (dx === 0 && dy === 1) return Direction.SOUTH;
                if (dx === 0 && dy === -1) return Direction.NORTH;
                
                return null;
            }
            
            // æŸ¥æ‰¾é™„è¿‘çš„æ”¯æ´å•ä½
            findNearbySupportUnits(srcTile, targetTile, playerId) {
                let totalSupport = 0;
                const directions = Object.values(Direction);
                
                // æ£€æŸ¥æºæ ¼å­å‘¨å›´çš„å‹å†›å•ä½
                for (const dir of directions) {
                    const [dx, dy] = DIRECTION_DELTAS[dir];
                    const checkX = srcTile.x + dx;
                    const checkY = srcTile.y + dy;
                    
                    if (checkX < 0 || checkX >= this.width || checkY < 0 || checkY >= this.height) continue;
                    
                    const tile = this.map[checkY][checkX];
                    
                    // å¦‚æœæ˜¯å‹å†›å•ä½ä¸”å¯ä»¥ç§»åŠ¨
                    if (tile.ownerId === playerId && tile.units > 1) {
                        // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                        if (this.canMoveToTarget(tile, targetTile)) {
                            totalSupport += tile.units - 1;
                        }
                    }
                }
                
                return totalSupport;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
            canMoveToTarget(srcTile, targetTile) {
                const dx = targetTile.x - srcTile.x;
                const dy = targetTile.y - srcTile.y;
                
                // å¦‚æœç›®æ ‡åœ¨ç›¸é‚»ä½ç½®
                if ((Math.abs(dx) === 1 && dy === 0) || (Math.abs(dy) === 1 && dx === 0)) {
                    return true;
                }
                
                return false;
            }
            
            getDirectionName(direction) {
                switch (direction) {
                    case Direction.NORTH: return "åŒ—";
                    case Direction.SOUTH: return "å—";
                    case Direction.WEST: return "è¥¿";
                    case Direction.EAST: return "ä¸œ";
                    default: return "æœªçŸ¥";
                }
            }
            
            getNextPlayerPriority() {
                if (this.playerMovePriority.length === 0) return -1;
                
                const playerId = this.playerMovePriority[this.currentPriorityIndex];
                this.currentPriorityIndex = (this.currentPriorityIndex + 1) % this.playerMovePriority.length;
                return playerId;
            }
            
            processMoveOrder(order) {
                const { playerId, srcX, srcY, direction, moveHalf } = order;
                const srcTile = this.map[srcY][srcX];
                
                // éªŒè¯æºæ ¼å­
                if (srcTile.ownerId !== playerId) return false;
                if (srcTile.units <= 1) return false;
                
                // è®¡ç®—ç›®æ ‡ä½ç½®
                const [dx, dy] = DIRECTION_DELTAS[direction];
                const destX = srcX + dx;
                const destY = srcY + dy;
                
                // æ£€æŸ¥è¾¹ç•Œ
                if (destX < 0 || destX >= this.width || destY < 0 || destY >= this.height) {
                    return false;
                }
                
                const destTile = this.map[destY][destX];
                
                // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å¯é€šè¿‡
                if (!destTile.isPassable()) return false;
                
                // è®¡ç®—ç§»åŠ¨å•ä½æ•°é‡
                const moveUnits = moveHalf ? Math.floor(srcTile.units / 2) : srcTile.units - 1;
                srcTile.units -= moveUnits;
                
                // è®¾ç½®ç§»åŠ¨å†·å´æ—¶é—´
                srcTile.lastMoved = this.halfturnCount;
                
                // è®°å½•ä¸Šä¸€æ­¥ä½ç½®
                if (destTile.ownerId !== playerId) {
                    destTile.lastPosition = {x: srcX, y: srcY};
                }
                
                // å¤„ç†ä¸åŒç±»å‹çš„ç›®æ ‡æ ¼å­
                if (destTile.ownerId === 0) {  // ä¸­æ€§æ ¼å­
                    // å¦‚æœæ˜¯ä¸­æ€§è¦å¡ï¼Œåˆ™è¿›è¡Œæˆ˜æ–—
                    if (destTile.type === TileType.STRONGHOLD) {
                        if (moveUnits > destTile.units) {
                            destTile.ownerId = playerId;
                            destTile.units = moveUnits - destTile.units;
                        } else {
                            destTile.units = destTile.units - moveUnits;
                        }
                    } else {
                        // ä¿®å¤ï¼šå¯¹äºéè¦å¡çš„ä¸­æ€§æ ¼å­ï¼Œç›´æ¥å é¢†ï¼Œä¸éœ€è¦æˆ˜æ–—
                        destTile.ownerId = playerId;
                        destTile.units = moveUnits;  // å…¨éƒ¨å•ä½ç§»åŠ¨åˆ°ç›®æ ‡æ ¼å­
                    }
                } else if (destTile.ownerId === playerId) {  // è‡ªå·±çš„æ ¼å­
                    destTile.units += moveUnits;
                } else {  // æ•Œæ–¹æ ¼å­
                    const enemyPlayerId = destTile.ownerId;
                    const enemyUnits = destTile.units;
                    
                    if (moveUnits > enemyUnits) {
                        destTile.ownerId = playerId;
                        destTile.units = moveUnits - enemyUnits;
                        
                        // æ£€æŸ¥æ˜¯å¦å é¢†é¦–éƒ½
                        if (destTile.type === TileType.CAPITAL) {
                            this.handleCapitalCapture(playerId, enemyPlayerId, destTile);
                        }
                    } else {
                        destTile.units = enemyUnits - moveUnits;
                    }
                }
                
                return true;
            }
            
            handleCapitalCapture(attackerId, defenderId, capitalTile) {
                const defender = this.players[defenderId];
                if (!defender) return;
                
                defender.isDefeated = true;
                this.gameState.defeatedPlayers.push(defenderId);
                this.gameState.messages.push(`ç©å®¶ ${attackerId} å é¢†äº†ç©å®¶ ${defenderId} çš„é¦–éƒ½ï¼`);
                
                // æ™®é€šè§„åˆ™ï¼šé¦–éƒ½å˜ä¸ºè¦å¡
                capitalTile.type = TileType.STRONGHOLD;
                
                // è½¬ç§»æ‰€æœ‰æ ¼å­
                for (const row of this.map) {
                    for (const tile of row) {
                        if (tile.ownerId === defenderId) {
                            tile.ownerId = attackerId;
                            tile.units = Math.floor(tile.units / 2) + 1;
                        }
                    }
                }
            }
            
            generateUnits() {
                for (const row of this.map) {
                    for (const tile of row) {
                        if (tile.ownerId === 0) continue;
                        
                        // é¦–éƒ½å’Œè¦å¡æ¯åŠå›åˆç”Ÿæˆå•ä½ï¼ˆä¿®å¤ï¼šç¡®ä¿åœ¨ç¬¬ä¸€ä¸ªåŠå›åˆå¼€å§‹æ—¶å°±ç”Ÿæˆï¼‰
                        if (tile.type === TileType.CAPITAL || tile.type === TileType.STRONGHOLD) {
                            // ç¡®ä¿åœ¨ç¬¬ä¸€ä¸ªåŠå›åˆå¼€å§‹æ—¶å°±ç”Ÿæˆå•ä½
                            tile.units += 1;
                        }
                        
                        // æ²¼æ³½æ¯åŠå›åˆæ¶ˆå¤±å•ä½
                        if (tile.type === TileType.SWAMP && tile.units > 0) {
                            tile.units -= 1;
                        }
                        
                        // æ¯25åŠå›åˆæ‰€æœ‰éä¸­æ€§é¢†åœ°äº§ç”Ÿå•ä½
                        if (this.halfturnCount % 25 === 0) {
                            tile.units += 1;
                        }
                    }
                }
            }
            
            updateLeaderboard() {
                const teamStats = [];
                
                for (const teamId in this.teams) {
                    if (teamId === "0") continue;
                    
                    const team = this.teams[teamId];
                    let totalUnits = 0;
                    let totalTiles = 0;
                    const playerStats = [];
                    
                    for (const player of team.players) {
                        let playerUnits = 0;
                        let playerTiles = 0;
                        
                        for (const row of this.map) {
                            for (const tile of row) {
                                if (tile.ownerId === player.id) {
                                    playerUnits += tile.units;
                                    playerTiles++;
                                }
                            }
                        }
                        
                        totalUnits += playerUnits;
                        totalTiles += playerTiles;
                        
                        playerStats.push({
                            playerId: player.id,
                            defeated: player.isDefeated,
                            units: playerUnits,
                            tiles: playerTiles
                        });
                    }
                    
                    playerStats.sort((a, b) => b.units - a.units);
                    
                    teamStats.push({
                        teamId,
                        totalUnits,
                        totalTiles,
                        players: playerStats
                    });
                }
                
                teamStats.sort((a, b) => b.totalUnits - a.totalUnits);
                this.gameState.leaderboard = teamStats;
            }
            
            selectTile(x, y) {
                this.selectedTile = { x, y };
                return this.map[y][x];
            }
            
            toggleAutoMode() {
                this.autoMode = !this.autoMode;
                return this.autoMode;
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameEnd() {
                // æ£€æŸ¥ç©å®¶1ï¼ˆäººç±»ï¼‰æ˜¯å¦å¤±è´¥
                const humanPlayer = this.players[1];
                if (humanPlayer && humanPlayer.isDefeated) {
                    this.gameOver = true;
                    this.winner = 2; // æœºå™¨äººè·èƒœ
                    return;
                }
                
                // æ£€æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦å¤±è´¥
                let humanWins = true;
                for (const playerId in this.players) {
                    if (playerId !== "1") {
                        const player = this.players[playerId];
                        if (!player.isDefeated) {
                            humanWins = false;
                        }
                    }
                }
                
                if (humanWins) {
                    this.gameOver = true;
                    this.winner = 1; // äººç±»è·èƒœ
                }
            }
            
            // é‡ç½®æ¸¸æˆ
            resetGame(width, height) {
                this.width = width;
                this.height = height;
                this.map = this.createMap(width, height);
                this.players = {};
                this.teams = {};
                this.playerMovePriority = [];
                this.currentPriorityIndex = 0;
                this.halfturnCount = 0;
                this.roundCount = 0;
                this.gameState = {
                    halfturnId: 0,
                    defeatedPlayers: [],
                    alivePlayers: [],
                    leaderboard: [],
                    messages: []
                };
                this.initNeutralTeam();
                this.selectedTile = null;
                this.autoMode = true; // é»˜è®¤å¼€å¯è‡ªåŠ¨æ¨¡å¼
                this.gameOver = false;
                this.winner = null;
                this.aiStatus = "æ¸¸æˆå·²é‡ç½®";
            }
        }
        
        class GameUI {
            constructor() {
                // ç­‰å¾…DOMå®Œå…¨åŠ è½½åå†åˆå§‹åŒ–
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.initialize());
                } else {
                    this.initialize();
                }
            }
            
            initialize() {
                this.game = new GeneralsGame(10, 10);
                this.initDOMReferences();
                this.setupEventListeners();
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ•™ç¨‹
                if (!localStorage.getItem('generalsTutorialShown')) {
                    this.tutorialScreen.style.display = 'flex';
                } else {
                    this.startScreen.style.display = 'flex';
                }
                
                this.renderMap();
                this.updateUI();
                
                // åˆå§‹åŒ–AIå¯è§†åŒ–çŠ¶æ€ - é»˜è®¤å…³é—­
                this.showGathering = false;
                this.showTarget = false;
                this.showAiMove = false;
            }
            
            initGame(width = 10, height = 10) {
                // é‡ç½®æ¸¸æˆ
                this.game.resetGame(width, height);
                
                // æ·»åŠ ç©å®¶ - äººç±»ç©å®¶
                this.game.addPlayer(1, 1, 1, 1);
                
                // è·å–AIæ•°é‡
                const aiCount = parseInt(document.querySelector('.ai-count-option.selected').dataset.count);
                this.game.aiCount = aiCount;
                
                // æ·»åŠ AIç©å®¶ - ä¿®å¤ä½ç½®é‡å é—®é¢˜
                const aiPositions = [];
                
                // æ ¹æ®AIæ•°é‡è®¾ç½®ä½ç½®ï¼Œç¡®ä¿ä¸é‡å 
                if (aiCount >= 1) {
                    // ç¬¬ä¸€ä¸ªAIåœ¨å³ä¸‹è§’
                    aiPositions.push({x: width-2, y: height-2});
                }
                if (aiCount >= 2) {
                    // ç¬¬äºŒä¸ªAIåœ¨å·¦ä¸‹è§’ï¼ˆé¿å…ä¸ç©å®¶1é‡å ï¼‰
                    aiPositions.push({x: 1, y: height-2});
                }
                if (aiCount >= 3) {
                    // ç¬¬ä¸‰ä¸ªAIåœ¨å³ä¸Šè§’
                    aiPositions.push({x: width-2, y: 1});
                }
                
                // æ·»åŠ AIç©å®¶
                for (let i = 0; i < aiCount; i++) {
                    const pos = aiPositions[i];
                    this.game.addPlayer(2 + i, 2 + i, pos.x, pos.y);
                }
                
                // è®¾ç½®åœ°å½¢ - è°ƒæ•´åœ°å½¢ç”Ÿæˆæ¦‚ç‡
                let connected = false;
                let attempts = 0;
                const maxAttempts = 20;
                
                while (!connected && attempts < maxAttempts) {
                    attempts++;
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const tile = this.game.map[y][x];
                            
                            // è·³è¿‡ç©å®¶é¦–éƒ½
                            if (tile.ownerId !== 0) continue;
                            
                            // åœ°å½¢æ¦‚ç‡ï¼šç©ºåœ°50%ï¼Œå±±åœ°25%ï¼Œæ²¼æ³½12.5%ï¼Œè¦å¡12.5%
                            const terrainTypes = [
                                TileType.PLAIN, TileType.PLAIN, TileType.PLAIN, TileType.PLAIN,
                                TileType.MOUNTAIN, TileType.MOUNTAIN,
                                TileType.SWAMP,
                                TileType.STRONGHOLD
                            ];
                            
                            tile.type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                            
                            // åªæœ‰è¦å¡å¯ä»¥æœ‰åˆå§‹å•ä½ï¼Œè®¾ç½®ä¸º10-40ä¹‹é—´çš„éšæœºæ•°
                            if (tile.type === TileType.STRONGHOLD) {
                                tile.units = Math.floor(Math.random() * 31) + 10; // 10-40
                            }
                        }
                    }
                    
                    // æ£€æŸ¥åœ°å›¾è¿é€šæ€§
                    connected = this.game.isMapConnected();
                    
                    if (!connected) {
                        // é‡ç½®ä¸­æ€§åœŸåœ°
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (this.game.map[y][x].ownerId === 0) {
                                    this.game.map[y][x].type = TileType.PLAIN;
                                }
                            }
                        }
                    }
                }
                
                if (!connected) {
                    this.addMessage("è­¦å‘Šï¼šåœ°å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åœ°å›¾");
                }
                
                // å¼ºåˆ¶é‡æ–°åˆ›å»ºæ‰€æœ‰æ ¼å­å…ƒç´ 
                this.tileElements = null;
                this.gameMap.style.setProperty('--map-size', width);
                
                // æ›´æ–°å¯è§æ€§ - ç¡®ä¿ç©å®¶é¦–éƒ½åˆå§‹å¯è§
                this.game.updateVisibility();
                
                // æ·»åŠ åˆå§‹æ¶ˆæ¯
                this.addMessage(`æ¸¸æˆå¼€å§‹ï¼åœ°å›¾å¤§å°: ${width}x${height}ï¼ŒAIæ•°é‡: ${aiCount}`);
                this.addMessage("ç‚¹å‡»ä½ çš„å•ä½ï¼Œç„¶åé€‰æ‹©ç§»åŠ¨æ–¹å‘");
            }
            
            initDOMReferences() {
                this.gameMap = document.getElementById('game-map');
                this.halfturnEl = document.getElementById('halfturn');
                this.roundEl = document.getElementById('round');
                this.currentPlayerEl = document.getElementById('current-player');
                this.messagesEl = document.getElementById('messages');
                this.leaderboardEl = document.getElementById('leaderboard');
                this.tickBtn = document.getElementById('tick-btn');
                this.clearBtn = document.getElementById('clear-btn');
                this.autoBtn = document.getElementById('auto-btn');
                this.stateDot = document.getElementById('state-dot');
                this.stateText = document.getElementById('state-text');
                this.aiInfoEl = document.getElementById('ai-info');
                this.aiStatusEl = document.getElementById('ai-status');
                this.gatheringStatusEl = document.getElementById('gathering-status');
                this.targetStatusEl = document.getElementById('target-status');
                this.aimoveStatusEl = document.getElementById('aimove-status');
                this.hideFogBtn = document.getElementById('hide-fog-btn');
                
                // æ•™ç¨‹ç•Œé¢å…ƒç´ 
                this.tutorialScreen = document.getElementById('tutorial-screen');
                this.tutorialStartButton = document.getElementById('tutorial-start-button');
                this.tutorialSkipButton = document.getElementById('tutorial-skip-button');
                
                // å¼€å§‹ç•Œé¢å…ƒç´ 
                this.startScreen = document.getElementById('start-screen');
                this.sizeOptions = document.querySelectorAll('.size-option');
                this.startButton = document.getElementById('start-button');
                this.aiCountOptions = document.querySelectorAll('.ai-count-option');
                
                // ç»“æŸç•Œé¢å…ƒç´ 
                this.endScreen = document.getElementById('end-screen');
                this.endTitle = document.getElementById('end-title');
                this.endMessage = document.getElementById('end-message');
                this.restartButton = document.getElementById('restart-button');
                
                // AIæ§åˆ¶æŒ‰é’®
                this.gatheringBtn = document.getElementById('gathering-btn');
                this.targetBtn = document.getElementById('target-btn');
                this.aimoveBtn = document.getElementById('aimove-btn');
            }
            
            renderMap() {
                if (!this.tileElements || 
                    this.tileElements.length !== this.game.height || 
                    this.tileElements[0].length !== this.game.width) {
                    // é¦–æ¬¡æ¸²æŸ“æˆ–åœ°å›¾å°ºå¯¸æ”¹å˜ï¼Œåˆ›å»ºæ‰€æœ‰æ ¼å­å…ƒç´ 
                    this.tileElements = [];
                    this.gameMap.innerHTML = '';
                    this.gameMap.style.setProperty('--map-size', this.game.width);
                    
                    for (let y = 0; y < this.game.height; y++) {
                        const rowElements = [];
                        for (let x = 0; x < this.game.width; x++) {
                            const tile = this.game.map[y][x];
                            const tileEl = this.createTileElement(tile);
                            this.gameMap.appendChild(tileEl);
                            rowElements.push(tileEl);
                        }
                        this.tileElements.push(rowElements);
                    }
                } else {
                    // æ›´æ–°ç°æœ‰æ ¼å­å…ƒç´ 
                    for (let y = 0; y < this.game.height; y++) {
                        for (let x = 0; x < this.game.width; x++) {
                            const tile = this.game.map[y][x];
                            const tileEl = this.tileElements[y][x];
                            this.updateTileElement(tileEl, tile);
                        }
                    }
                }
                
                // æ›´æ–°AIçŠ¶æ€ä¿¡æ¯
                this.aiStatusEl.textContent = this.game.aiStatus;
            }
            
            createTileElement(tile) {
                const tileEl = document.createElement('div');
                tileEl.className = 'tile';
                
                if (tile.lighten) {
                    tileEl.classList.add('lighten');
                }
                
                // è®¾ç½®èƒŒæ™¯é¢œè‰²
                const bgColor = PLAYER_COLORS[tile.ownerId] || TERRAIN_COLORS[tile.type] || '#27ae60';
                tileEl.style.background = `linear-gradient(135deg, ${this.adjustColor(bgColor, -20)}, ${bgColor})`;
                
                // è®¾ç½®å†…å®¹
                tileEl.innerHTML = `
                    <div class="tile-content">${tile.units > 0 ? tile.units : ''}</div>
                    <div class="tile-type">${TERRAIN_SYMBOLS[tile.type] || ''}</div>
                `;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                tileEl.addEventListener('click', () => this.handleTileClick(tile.x, tile.y));
                
                return tileEl;
            }
            
            updateTileElement(tileEl, tile) {
                // æ›´æ–°é€‰ä¸­çŠ¶æ€
                if (this.game.selectedTile && 
                    this.game.selectedTile.x === tile.x && 
                    this.game.selectedTile.y === tile.y) {
                    tileEl.classList.add('selected');
                } else {
                    tileEl.classList.remove('selected');
                }
                
                // æ›´æ–°é«˜äº®çŠ¶æ€
                if (tile.lighten) {
                    tileEl.classList.add('lighten');
                } else {
                    tileEl.classList.remove('lighten');
                }
                
                // æ›´æ–°AIçŠ¶æ€å¯è§†åŒ–ï¼ˆæ ¹æ®ç”¨æˆ·è®¾ç½®ï¼‰
                tileEl.classList.remove('gathering', 'gather-target', 'ai-move');
                
                if (tile.aiState === 'gathering' && this.showGathering) {
                    tileEl.classList.add('gathering');
                } else if (tile.aiState === 'target' && this.showTarget) {
                    tileEl.classList.add('gather-target');
                } else if (tile.aiState === 'ai-move' && this.showAiMove) {
                    tileEl.classList.add('ai-move');
                }
                
                // æ›´æ–°æˆ˜äº‰è¿·é›¾çŠ¶æ€ - ä¿®å¤ç©å®¶è¢«è¦†ç›–é—®é¢˜
                if (this.game.hideFog && !tile.visible) {
                    tileEl.classList.add('fog');
                } else {
                    tileEl.classList.remove('fog');
                }
                
                // ç¡®ä¿ç©å®¶é¦–éƒ½æ€»æ˜¯å¯è§ï¼ˆå³ä½¿æˆ˜äº‰è¿·é›¾å¼€å¯ï¼‰
                if (tile.type === TileType.CAPITAL && tile.ownerId === 1) {
                    tileEl.classList.remove('fog');
                }
                
                // æ›´æ–°èƒŒæ™¯é¢œè‰²
                const bgColor = PLAYER_COLORS[tile.ownerId] || TERRAIN_COLORS[tile.type] || '#27ae60';
                tileEl.style.background = `linear-gradient(135deg, ${this.adjustColor(bgColor, -20)}, ${bgColor})`;
                
                // æ›´æ–°å†…å®¹
                const contentEl = tileEl.querySelector('.tile-content');
                if (contentEl) {
                    contentEl.textContent = tile.units > 0 ? tile.units : '';
                }
                
                const typeEl = tileEl.querySelector('.tile-type');
                if (typeEl) {
                    typeEl.textContent = TERRAIN_SYMBOLS[tile.type] || '';
                }
            }
            
            adjustColor(color, amount) {
                let usePound = false;
                
                if (color[0] === "#") {
                    color = color.slice(1);
                    usePound = true;
                }
                
                const num = parseInt(color, 16);
                let r = (num >> 16) + amount;
                
                if (r > 255) r = 255;
                else if (r < 0) r = 0;
                
                let b = ((num >> 8) & 0x00FF) + amount;
                
                if (b > 255) b = 255;
                else if (b < 0) b = 0;
                
                let g = (num & 0x0000FF) + amount;
                
                if (g > 255) g = 255;
                else if (g < 0) g = 0;
                
                return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
            }
            
            handleTileClick(x, y) {
                const tile = this.game.selectTile(x, y);
                this.renderMap();
            }
            
            handleDirectionClick(dir) {
                if (!this.game.selectedTile) return;
                
                const playerId = 1; // å›ºå®šä¸ºç©å®¶1
                const moveHalf = false; // ä¸å†ä½¿ç”¨åŠç§»åŠ¨é€‰é¡¹
                const { x, y } = this.game.selectedTile;
                
                // æ˜ å°„æ–¹å‘å­—ç¬¦åˆ°æšä¸¾å€¼
                const directionMap = {
                    'n': Direction.NORTH,
                    's': Direction.SOUTH,
                    'w': Direction.WEST,
                    'e': Direction.EAST
                };
                
                if (directionMap[dir] !== undefined) {
                    this.game.appendOrder(playerId, x, y, directionMap[dir], moveHalf);
                    this.game.selectedTile = null;
                    this.renderMap();
                    this.addMessage(`ç©å®¶ ${playerId}: ä» (${x},${y}) å‘ ${dir.toUpperCase()} ç§»åŠ¨`);
                    
                    // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼Œç«‹å³æ‰§è¡Œtick
                    if (this.game.autoMode) {
                        setTimeout(() => {
                            this.game.tick();
                            this.updateUI();
                            this.checkGameEnd();
                        }, 300);
                    }
                }
            }
            
            toggleAIVisualization(type) {
                switch(type) {
                    case 'gathering':
                        this.showGathering = !this.showGathering;
                        this.gatheringBtn.classList.toggle('active', this.showGathering);
                        this.gatheringStatusEl.textContent = `é›†ç»“å…µåŠ›: ${this.showGathering ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIé›†ç»“å…µåŠ›å¯è§†åŒ–: ${this.showGathering ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                    case 'target':
                        this.showTarget = !this.showTarget;
                        this.targetBtn.classList.toggle('active', this.showTarget);
                        this.targetStatusEl.textContent = `æ”»å‡»ç›®æ ‡: ${this.showTarget ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIæ”»å‡»ç›®æ ‡å¯è§†åŒ–: ${this.showTarget ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                    case 'aimove':
                        this.showAiMove = !this.showAiMove;
                        this.aimoveBtn.classList.toggle('active', this.showAiMove);
                        this.aimoveStatusEl.textContent = `AIç§»åŠ¨: ${this.showAiMove ? 'å¼€å¯' : 'å…³é—­'}`;
                        this.addMessage(`AIç§»åŠ¨å¯è§†åŒ–: ${this.showAiMove ? 'å¼€å¯' : 'å…³é—­'}`);
                        break;
                }
                this.renderMap();
            }
            
            toggleFogVisibility() {
                const isFogHidden = this.game.toggleFogVisibility();
                this.hideFogBtn.textContent = isFogHidden ? "æ˜¾ç¤ºæ‰€æœ‰æ ¼å­" : "éšè—éæ˜ç¤ºæ ¼å­";
                this.hideFogBtn.classList.toggle('active', isFogHidden);
                this.addMessage(`æˆ˜äº‰è¿·é›¾: ${isFogHidden ? 'å¼€å¯' : 'å…³é—­'}`);
                this.renderMap();
            }
            
            setupEventListeners() {
                // æ–¹å‘æ§åˆ¶
                document.querySelectorAll('.dir-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.handleDirectionClick(btn.dataset.dir);
                    });
                });
                
                // æ§åˆ¶æŒ‰é’®
                this.tickBtn.addEventListener('click', () => {
                    this.game.tick();
                    this.updateUI();
                    this.checkGameEnd();
                });
                
                this.clearBtn.addEventListener('click', () => {
                    this.game.clearQueue(1); // åªæ¸…ç©ºç©å®¶1çš„é˜Ÿåˆ—
                    this.addMessage(`å·²æ¸…ç©ºç©å®¶é˜Ÿåˆ—`);
                });
                
                this.autoBtn.addEventListener('click', () => {
                    const isAuto = this.game.toggleAutoMode();
                    this.autoBtn.textContent = isAuto ? "å…³é—­è‡ªåŠ¨" : "è‡ªåŠ¨æ¨¡å¼";
                    this.autoBtn.style.background = isAuto 
                        ? "linear-gradient(to bottom, #e74c3c, #c0392b)" 
                        : "linear-gradient(to bottom, #4a00e0, #8e2de2)";
                    
                    // æ›´æ–°æ¸¸æˆçŠ¶æ€æŒ‡ç¤ºå™¨
                    if (isAuto) {
                        this.stateDot.className = "state-dot auto";
                        this.stateText.textContent = "è‡ªåŠ¨æ¨¡å¼è¿è¡Œä¸­";
                        this.addMessage("å·²å¼€å¯è‡ªåŠ¨æ¨¡å¼");
                    } else {
                        this.stateDot.className = "state-dot paused";
                        this.stateText.textContent = "æ¸¸æˆæš‚åœä¸­";
                        this.addMessage("å·²å…³é—­è‡ªåŠ¨æ¨¡å¼");
                    }
                });
                
                // AIå¯è§†åŒ–æ§åˆ¶æŒ‰é’®
                this.gatheringBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('gathering');
                });
                
                this.targetBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('target');
                });
                
                this.aimoveBtn.addEventListener('click', () => {
                    this.toggleAIVisualization('aimove');
                });
                
                // æˆ˜äº‰è¿·é›¾æŒ‰é’®
                this.hideFogBtn.addEventListener('click', () => {
                    this.toggleFogVisibility();
                });
                
                // é”®ç›˜äº‹ä»¶ç›‘å¬
                document.addEventListener('keydown', (e) => {
                    if (!this.game.selectedTile) return;
                    
                    const keyMap = {
                        'w': 'n',
                        'a': 'w',
                        's': 's',
                        'd': 'e'
                    };
                    
                    if (keyMap[e.key.toLowerCase()]) {
                        this.handleDirectionClick(keyMap[e.key.toLowerCase()]);
                    }
                });
                
                // æ•™ç¨‹ç•Œé¢äº‹ä»¶
                this.tutorialStartButton.addEventListener('click', () => {
                    localStorage.setItem('generalsTutorialShown', 'true');
                    this.tutorialScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                });
                
                this.tutorialSkipButton.addEventListener('click', () => {
                    localStorage.setItem('generalsTutorialShown', 'true');
                    this.tutorialScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                });
                
                // å¼€å§‹ç•Œé¢äº‹ä»¶
                this.sizeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.sizeOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                this.aiCountOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.aiCountOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                this.startButton.addEventListener('click', () => {
                    const selectedOption = document.querySelector('.size-option.selected');
                    const size = parseInt(selectedOption.dataset.size);
                    this.initGame(size, size);
                    this.startScreen.style.display = 'none';
                    this.updateUI();
                });
                
                // ç»“æŸç•Œé¢äº‹ä»¶
                this.restartButton.addEventListener('click', () => {
                    this.endScreen.style.display = 'none';
                    this.startScreen.style.display = 'flex';
                });
            }
            
            updateUI() {
                this.halfturnEl.textContent = this.game.halfturnCount;
                this.roundEl.textContent = this.game.roundCount;
                this.currentPlayerEl.textContent = 1; // å›ºå®šä¸ºç©å®¶1
                this.renderMap();
                this.renderMessages();
                this.renderLeaderboard();
            }
            
            addMessage(text) {
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                messageEl.textContent = text;
                this.messagesEl.prepend(messageEl);
                
                // é™åˆ¶æ¶ˆæ¯æ•°é‡
                if (this.messagesEl.children.length > 10) {
                    this.messagesEl.removeChild(this.messagesEl.lastChild);
                }
            }
            
            renderMessages() {
                this.messagesEl.innerHTML = '';
                
                if (this.game.gameState.messages.length === 0) {
                    this.addMessage("ç­‰å¾…æ¸¸æˆå¼€å§‹...");
                    return;
                }
                
                this.game.gameState.messages.forEach(msg => {
                    this.addMessage(msg);
                });
            }
            
            renderLeaderboard() {
                this.leaderboardEl.innerHTML = '';
                
                if (this.game.gameState.leaderboard.length === 0) {
                    this.leaderboardEl.innerHTML = '<div class="team-rank">æš‚æ— æ’åæ•°æ®</div>';
                    return;
                }
                
                this.game.gameState.leaderboard.forEach(team => {
                    const teamEl = document.createElement('div');
                    teamEl.className = 'team-rank';
                    teamEl.innerHTML = `<strong>é˜Ÿä¼ ${team.teamId}</strong> - å•ä½: ${team.totalUnits}, é¢†åœ°: ${team.totalTiles}`;
                    
                    team.players.forEach(player => {
                        const playerEl = document.createElement('div');
                        playerEl.className = 'player-rank';
                        playerEl.innerHTML = `
                            <span>ç©å®¶ ${player.playerId} - ${player.defeated ? 'å·²å¤±è´¥' : 'æ´»è·ƒ'}</span>
                            <span>å•ä½: ${player.units}, é¢†åœ°: ${player.tiles}</span>
                        `;
                        teamEl.appendChild(playerEl);
                    });
                    
                    this.leaderboardEl.appendChild(teamEl);
                });
            }
            
            checkGameEnd() {
                if (this.game.gameOver) {
                    if (this.game.winner === 1) {
                        this.showEndScreen(true, "æ­å–œä½ å‡»è´¥äº†æ‰€æœ‰æ•Œäººï¼");
                    } else {
                        this.showEndScreen(false, "ä½ çš„é¦–éƒ½å·²è¢«å é¢†ï¼Œä¸‹æ¬¡å†æ¥å†å‰ï¼");
                    }
                }
            }
            
            showEndScreen(isVictory, message) {
                if (isVictory) {
                    this.endTitle.textContent = "èƒœåˆ©ï¼";
                    this.endTitle.className = "end-title victory";
                } else {
                    this.endTitle.textContent = "å¤±è´¥";
                    this.endTitle.className = "end-title defeat";
                }
                
                this.endMessage.textContent = message;
                this.endScreen.style.display = "flex";
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            const gameUI = new GameUI();
        });
    </script>
</body>
</html>